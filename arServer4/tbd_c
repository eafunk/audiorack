gst-launch-1.0 playbin uri='file:///home/ethan/Music/2-02%20IPlayYouListen%20(Live).mp3' audio-sink='jackaudiosink' video-sink='fakesink'

void executeLogScript(uint32_t logID);
unsigned char handle_stat(ctl_session *session)
unsigned char handle_execute(ctl_session *session);
unsigned char handle_mutex(ctl_session *session);

unsigned char handle_getdm(ctl_session *session);
unsigned char handle_setdm(ctl_session *session);
unsigned char handle_listdm(ctl_session *session);
unsigned char handle_rotatelog(ctl_session *session);
unsigned char handle_iaxstream(ctl_session *session);
unsigned char handle_getuid(ctl_session *session);
unsigned char handle_logmeta(ctl_session *session);
unsigned char handle_inuid(ctl_session *session);
unsigned char handle_debugout(ctl_session *session);
unsigned char handle_deltask(ctl_session *session);
unsigned char handle_task(ctl_session *session);
unsigned char handle_tasks(ctl_session *session);
unsigned char handle_load(ctl_session *session);
unsigned char handle_playnow(ctl_session *session);
unsigned char handle_back(ctl_session *session);
unsigned char handle_ahead(ctl_session *session);
unsigned char handle_rstat(ctl_session *session);
unsigned char handle_setstat(ctl_session *session);
unsigned char handle_feed(ctl_session *session);
unsigned char handle_delete(ctl_session *session);
unsigned char handle_move(ctl_session *session);
unsigned char handle_add(ctl_session *session);
unsigned char handle_uadd(ctl_session *session);
unsigned char handle_split(ctl_session *session);
unsigned char handle_waitseg(ctl_session *session);
unsigned char handle_segnow(ctl_session *session);
unsigned char handle_segall(ctl_session *session);
unsigned char handle_fadeprior(ctl_session *session);
unsigned char handle_list(ctl_session *session);
unsigned char handle_expand(ctl_session *session);
unsigned char handle_newrec(ctl_session *session);
unsigned char handle_initrec(ctl_session *session);
unsigned char handle_startrec(ctl_session *session);
unsigned char handle_stoprec(ctl_session *session);
unsigned char handle_recgain(ctl_session *session);
unsigned char handle_lockrec(ctl_session *session);
unsigned char handle_unlockrec(ctl_session *session);
unsigned char handle_closerec(ctl_session *session);
unsigned char handle_debugrec(ctl_session *session);
unsigned char handle_jsonpost(ctl_session *session);
unsigned char handle_fxcue(ctl_session *session);
unsigned char handle_fxlist(ctl_session *session);
unsigned char handle_fxslots(ctl_session *session);
unsigned char handle_fxinsert(ctl_session *session);
unsigned char handle_fxparam(ctl_session *session);
unsigned char handle_fxbypass(ctl_session *session);
unsigned char handle_fxvalstr(ctl_session *session);
unsigned char handle_fxsave(ctl_session *session);
unsigned char handle_fxpreset(ctl_session *session);
unsigned char handle_fxwatch(ctl_session *session);
void setSessionFXWatch(int cs, AUManager *aum, unsigned char slot, uint32_t AID);
unsigned char handle_getcodecs(ctl_session *session);
unsigned char lsFXConfigDir(ctl_session *session);
int fxdirSelect(struct dirent *ent);
unsigned char saveFXConfigFile(AUManager *aum[], unsigned char count, char *fileName);
float processLoad(void);
float totalLoad(void);
void modbusTrigger(unsigned char state, char *conf);
unsigned char handle_coilset(ctl_session *session, unsigned char val);
unsigned char handle_modbuspoll(ctl_session *session);
void modbusPoll(TaskItem *parent);
char modbusQuery(int *sock, char *addr, unsigned char unitID, unsigned short inputID);

unsigned char handle_stat(ctl_session *session)
{
	char buf[4096]; /* send data buffer */
    int tx_length;

	// play list status
	if(plRunning)
		tx_length = snprintf(buf, sizeof buf, "ListRev=%u %s\n", (unsigned int)plRev, "Running");
	else
		tx_length = snprintf(buf, sizeof buf, "ListRev=%u %s\n", (unsigned int)plRev, "Stopped");
	my_send(session->cs, buf, tx_length, session->silent);
	
	// last log entry time
	tx_length = snprintf(buf, sizeof buf, "LogTime=%ld\n", (long)ProgramLoger->logChangeTime);
	my_send(session->cs, buf, tx_length, session->silent);
	
	// automation status
	lMutex->readLock(true);
	if(autoState == auto_unatt){
		tx_length = snprintf(buf, sizeof buf, "auto=on %s\n", fillStr.c_str());
	}else{
		if(autoState == auto_live){
			if(atoi(GetMetaData(0, "auto_live_flags").c_str()) & live_fill)
				tx_length = snprintf(buf, sizeof buf, "auto=live %s\n", fillStr.c_str());
			else
				tx_length = snprintf(buf, sizeof buf, "auto=live\n");
		}else{
			tx_length = snprintf(buf, sizeof buf, "auto=off\n");
		}
	}
	lMutex->readUnlock();
	my_send(session->cs, buf, tx_length, session->silent);
	
	// iax telephone interface status
	if(iax_process_thread){
		if(iaxp_get_reg_state())
			tx_length = snprintf(buf, sizeof buf, "iaxPhone=registered\n");
		else
			tx_length = snprintf(buf, sizeof buf, "iaxPhone=unregistered\n");
	}else
		tx_length = snprintf(buf, sizeof buf, "iaxPhone=off\n");
	my_send(session->cs, buf, tx_length, session->silent);

	return rNone;
}

unsigned char handle_mutex(ctl_session *session)
{
	char buf[4096]; /* send data buffer */
    int tx_length;
	int i;

	for(i=0; i<gLockedMem->inBus; i++){
		tx_length = snprintf(buf, sizeof buf, "pLocks[%i] - player: %c %s\n", i, pLocks[i]->getState(), pLocks[i]->writeLockOwner);
		my_send(session->cs, buf, tx_length, session->silent);
	}
	tx_length = snprintf(buf, sizeof buf, "lMutex - play list: %c %s\n", lMutex->getState(), lMutex->writeLockOwner);
	my_send(session->cs, buf, tx_length, session->silent);
	tx_length = snprintf(buf, sizeof buf, "dMutex - metaData list: %c %s\n", dMutex->getState(), dMutex->writeLockOwner);
	my_send(session->cs, buf, tx_length, session->silent);
	tx_length = snprintf(buf, sizeof buf, "tMutex - task list: %c %s\n", tMutex->getState(), tMutex->writeLockOwner);
	my_send(session->cs, buf, tx_length, session->silent);
	tx_length = snprintf(buf, sizeof buf, "rMutex - recorder list: %c %s\n", rMutex->getState(), rMutex->writeLockOwner);
	my_send(session->cs, buf, tx_length, session->silent);
	if(pthread_mutex_trylock(&sMutex) == 0){
		pthread_mutex_unlock(&sMutex);
		tx_length = snprintf(buf, sizeof buf, "sMutex - session: -\n");
		my_send(session->cs, buf, tx_length, session->silent);
	}else{
		tx_length = snprintf(buf, sizeof buf, "sMutex - session: x\n");
		my_send(session->cs, buf, tx_length, session->silent);
	}
	if(pthread_mutex_trylock(&iMutex) == 0){
		 pthread_mutex_unlock(&iMutex);
		tx_length = snprintf(buf, sizeof buf, "iMutex - input device: -\n");
		my_send(session->cs, buf, tx_length, session->silent);
	}else{
		tx_length = snprintf(buf, sizeof buf, "iMutex - input device: x\n");
		my_send(session->cs, buf, tx_length, session->silent);
	}
	if(pthread_mutex_trylock(&oMutex) == 0){
		 pthread_mutex_unlock(&oMutex);
		tx_length = snprintf(buf, sizeof buf, "oMutex - output device: -\n");
		my_send(session->cs, buf, tx_length, session->silent);
	}else{
		tx_length = snprintf(buf, sizeof buf, "oMutex - output device: x\n");
		my_send(session->cs, buf, tx_length, session->silent);
	}
	if(pthread_mutex_trylock(&gLockedMem->mMutex) == 0){
		 pthread_mutex_unlock(&gLockedMem->mMutex);
		tx_length = snprintf(buf, sizeof buf, "mMutex - master output: -\n");
		my_send(session->cs, buf, tx_length, session->silent);
	}else{
		tx_length = snprintf(buf, sizeof buf, "mMutex - master output: x\n");
		my_send(session->cs, buf, tx_length, session->silent);
	}
	if(pthread_mutex_trylock(&mgrMutex) == 0){
		 pthread_mutex_unlock(&mgrMutex);
		tx_length = snprintf(buf, sizeof buf, "mgrMutex - list manager: -\n");
		my_send(session->cs, buf, tx_length, session->silent);
	}else{
		tx_length = snprintf(buf, sizeof buf, "mgrMutex - list manager: x\n");
		my_send(session->cs, buf, tx_length, session->silent);
	}
	return rNone;
}

unsigned char handle_getdm(ctl_session *session)
{
	char buf[4096]; /* send data buffer */
    int tx_length;
	uint32_t i;
	string name;
	uint32_t dest;
	CFStringRef originalStr, escapedStr;
	int size;
	char *uidStr;

	// first param is device UID
	if(session->save_pointer != NULL){
		if(!session->silent){
			i = 0;
			tx_length = snprintf(buf, sizeof buf, "Chan#\tDest ID\tDest Name\n");
			my_send(session->cs, buf, tx_length, session->silent);
			// URL type escape (%nn) the string, except for " " chars.
			if(escapedStr = CFStringCreateWithCString(NULL, session->save_pointer, kCFStringEncodingUTF8)){
				if(originalStr = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(NULL, escapedStr, CFSTR(""), kCFStringEncodingUTF8)){
					size = ((2 * CFStringGetLength(originalStr)) + 1) * sizeof(char);
					uidStr = (char *)malloc(size);
					if(CFStringGetCString(originalStr, uidStr, size, kCFStringEncodingUTF8)){
						while(ReturnDevDMDest(&dest, &name, uidStr, i)){
							tx_length = snprintf(buf, sizeof(buf), "%u\t%u\t%s\n", (unsigned int)i,  (unsigned int)dest, name.c_str());
							my_send(session->cs, buf, tx_length, session->silent);
							i++;
						}
					}
					free(uidStr);
					CFRelease(originalStr);
				}
				CFRelease(escapedStr);
			}
		}
		return rNone;
	}
	session->errMSG = "Missing parameter\n";
	return rError;
}

unsigned char handle_setdm(ctl_session *session)
{
	int aInt;
	uint32_t aLong;
	char *param;
	CFStringRef originalStr, escapedStr;
	int size;
	char *uidStr;
	
	// first parameter, device input channel number
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		aInt = atoi(param);
		// second param is destination ID to route this channel to
		param = strtok_r(NULL, " ", &session->save_pointer);
		if(param != NULL){
			aLong = atoi(param);
			// third param is device UID
			if(session->save_pointer != NULL){
				uidStr = NULL;
				// URL type escape (%nn) the string, except for " " chars.
				if(escapedStr = CFStringCreateWithCString(NULL, session->save_pointer, kCFStringEncodingUTF8)){
					if(originalStr = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(NULL, escapedStr, CFSTR(""), kCFStringEncodingUTF8)){
						size = ((2 * CFStringGetLength(originalStr)) + 1) * sizeof(char);
						uidStr = (char *)malloc(size);
						if(!CFStringGetCString(originalStr, uidStr, size, kCFStringEncodingUTF8)){
							free(uidStr);
							uidStr = NULL;
						}
						CFRelease(originalStr);
					}
					CFRelease(escapedStr);
				}
				if(uidStr){
					if(SetDMDest(uidStr, aInt, aLong)){
						free(uidStr);
						return rNone;
					}
					free(uidStr);
				}
				session->errMSG = "Device does not support input direct monitoring\n";
				return rError;
			}
		}
	} 
	session->errMSG = "Missing parameter\n";
	return rError;
}

unsigned char handle_listdm(ctl_session *session)
{
	char buf[4096]; /* send data buffer */
    int tx_length;
	char *param;
	int aInt;
	CFStringRef originalStr, escapedStr;
	int size;
	char *uidStr;

	// first parameter, device input channel number
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		aInt = atoi(param);
		// second param is device UID
		if(session->save_pointer != NULL){
			tx_length = snprintf(buf, sizeof buf, "Dest ID\tDest Name\n");
			my_send(session->cs, buf, tx_length, session->silent);
			if(!session->silent){
				uidStr = NULL;
				// URL type escape (%nn) the string, except for " " chars.
				if(escapedStr = CFStringCreateWithCString(NULL, session->save_pointer, kCFStringEncodingUTF8)){
					if(originalStr = CFURLCreateStringByReplacingPercentEscapesUsingEncoding(NULL, escapedStr, CFSTR(""), kCFStringEncodingUTF8)){
						size = ((2 * CFStringGetLength(originalStr)) + 1) * sizeof(char);
						uidStr = (char *)malloc(size);
						if(!CFStringGetCString(originalStr, uidStr, size, kCFStringEncodingUTF8)){
							free(uidStr);
							uidStr = NULL;
						}
						CFRelease(originalStr);
					}
					CFRelease(escapedStr);
				}
				if(uidStr){
					ReturnDevDMDestList(session->cs, buf, sizeof buf, uidStr, aInt);
					free(uidStr);
				}
			}
			return rNone;
		}
	}
	session->errMSG = "Missing parameter\n";
	return rError;
}

unsigned char handle_iaxstream(ctl_session *session)
{	
	int portNum;
	string str;
	unsigned char udpInData[65538], tcpInData[65538], trash[1];
	unsigned char *tcpOutPtr;
	char *tempPtr;
	int size, n, tcpOutSize, tcpInSize, udpOutSize;
	fd_set read_fds, write_fds, exc_fds;
	struct timeval tv;
    struct sockaddr_in adrRec;		// Internet address struct
	int dgrm;
	int h;
	struct sched_param p;

	// input error checking
	if(session->cs == 0){
		session->errMSG = "This command can only be used from a tcp control session.\n";
		return rError;
	}
	for(n=0; n < maxthread; n++){
		if((tp[n].client_socket == session->cs) && (tp[n].use_tcp)){
			session->errMSG = "This command can not be used on a session with notifications enabled.\n";
			return rError;
		}
	}
	size = 65538;
	setsockopt(session->cs, SOL_SOCKET, SO_SNDBUF, &size, sizeof(size));

	// open iax datagram socket
	if((dgrm = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP)) < 0){
		// close the connections
		close(session->cs);
		return rNone;
	}
	size = 65536;
	setsockopt(dgrm, SOL_SOCKET, SO_SNDBUF, &size, sizeof(size));
	
	size = sizeof(adrRec);
	bzero(&adrRec, size);
	adrRec.sin_family = AF_INET;
	adrRec.sin_addr.s_addr = 0;
	adrRec.sin_port = 0;
	// bind to next port available
	if(bind(dgrm, (struct sockaddr *)&adrRec, size) < 0){
		close(session->cs);
		close(dgrm);
		return rNone;
	}
	// set up destination udp address for this computer's IP address at the iax port number
	bzero(&adrRec, sizeof(adrRec));
	adrRec.sin_addr.s_addr = inet_addr("127.0.0.1");
	adrRec.sin_family = AF_INET;
	str = GetMetaData(0, "iax_port_number");
	if((portNum = atoi(str.c_str())) == 0);
		portNum = 4569; // default iax port number
	adrRec.sin_port = htons(portNum);

	tempPtr = "[session begin]";
	if(write(session->cs, tempPtr, strlen(tempPtr)) != (ssize_t)strlen(tempPtr)){
		close(session->cs);
		close(dgrm);
		return rNone;
	}

	tcpInData[0] = 0;
	tcpInData[1] = 0;
	tcpOutPtr = udpInData;
	tcpInSize = 0;
	tcpOutSize = 0;
	udpOutSize = 0;
		
	// make this a high priority thread
	p.sched_priority = sched_get_priority_max(SCHED_FIFO);
	pthread_setschedparam(pthread_self(), SCHED_FIFO, &p);
	
	// UDP packets are framed for TCP send/receive as a 2 byte packet count (LSB first), followed by count bytes of packet data
//	adrRec.sin_port = 0;
	while(1){
		h = 0;
		FD_ZERO(&read_fds);
		FD_ZERO(&write_fds);
		FD_ZERO(&exc_fds);
		
		// Default wake time in 2 seconds for good measure
		tv.tv_sec = 2;
		tv.tv_usec = 0;

		if(tcpOutSize)
			FD_SET(session->cs, &write_fds);
			
		if(udpOutSize)
			// udp packet waiting to be sent
			FD_SET(dgrm, &write_fds);
		else
			// only read tcp if there is no outgoing udp data in the buffer
			FD_SET(session->cs, &read_fds);	
			
		FD_SET(dgrm, &read_fds);		
		FD_SET(session->cs, &exc_fds);
		
		if(session->cs > h) 
			h = session->cs;
		if(dgrm > h) 
			h = dgrm;

		if(select(h+1, &read_fds, &write_fds, &exc_fds, &tv) > 0){
			if(FD_ISSET(session->cs, &exc_fds)){
				// control socket error (closed?) We are done.
//fprintf(stdout, "Exception on tcp socket\n");
				break;
			}
			
			if(FD_ISSET(session->cs, &write_fds)){
				if(tcpOutSize){
					n = send(session->cs, tcpOutPtr, tcpOutSize, 0);
					if(n > 0){
						tcpOutSize = tcpOutSize - n;
						tcpOutPtr = tcpOutPtr + n;
					}else 
						break;
//fprintf(stdout, "tcp sent %d\n", n);
				}	
				continue;
			}
			if(FD_ISSET(dgrm, &write_fds)){
				if(udpOutSize){
					if(adrRec.sin_port)
						// send only if we have an address to send to, otherwise, just trash it
						sendto(dgrm,tcpInData + 2, udpOutSize, 0, (struct sockaddr *)&adrRec, sizeof(adrRec));
//fprintf(stdout, "udp sent %d\n", udpOutSize);
					udpOutSize = 0;
				}	
				continue;				
			}

			if(FD_ISSET(dgrm, &read_fds)){
				if(tcpOutSize == 0){
					// no udp data pending to send out tcp port... add new packet
/*					if(adrRec.sin_port == 0){
						// no reply address set yet... set reply address to source of first udp packet received
						socklen_t ssize;
						ssize = sizeof(adrRec);
						n = recvfrom(dgrm, udpInData + 2, sizeof(udpInData) - 2, 0, (struct sockaddr*)&adrRec, &ssize);
					}else
*/						n = recvfrom(dgrm, udpInData + 2, sizeof(udpInData) - 2, 0, NULL, NULL);					
					if(n > 0){
						udpInData[0] = (unsigned char)(n & 0x00ff);
						udpInData[1] = (unsigned char)((n >> 8) & 0x00ff);
						tcpOutSize = n + 2;
						tcpOutPtr = udpInData;
//fprintf(stdout, "udp recv %d\n", n);
					}
				}else{
					// trash packet... we are still waiting to send the last one
					n = recvfrom(dgrm, trash, sizeof(trash), 0, NULL, NULL);
//fprintf(stdout, "udp recv dump\n");
				}
				continue;
			}
			if(FD_ISSET(session->cs, &read_fds)){
				if(tcpInSize < 2){
					n = read(session->cs, tcpInData + tcpInSize, 2 - tcpInSize);
					if(n > 0)
						tcpInSize = tcpInSize + n;
					size = 0;
				}else{
					size = (uint32_t)tcpInData[0] + ((uint32_t)tcpInData[1] << 8);
					n = read(session->cs, tcpInData + tcpInSize, size - (tcpInSize - 2));
					if(n > 0)
						tcpInSize = tcpInSize + n;
				}
				if(n > 0){
//fprintf(stdout, "tcp recv %d of %d\n", n, size);
					if((tcpInSize > 2) && (tcpInSize == (size + 2))){
						udpOutSize = size;
						tcpInSize = 0;
					}
				}else{
//					if(n == 0)
//						fprintf(stdout, "Error on TCP socket 0\n");
						
					// control socket error (closed?) We are done.
//					fprintf(stdout, "Error on TCP socket\n");
					break;				
				}
			}
		}
	}
	
	// close the connections
	close(session->cs);
	close(dgrm);
	return rNone;
}

unsigned char handle_getuid(ctl_session *session)
{
	char buf[16]; /* send data buffer */
    int tx_length;
	char *param;
	int i;
	ARPlayer *instance;
	uint32_t uid;
	
	// search for the specified item in the players, then in the playlist queue
	uid = 0;
	if(session->save_pointer != NULL){		
		// first parameter: metadata property string
		param = strtok_r(NULL, " ", &session->save_pointer);
		if(param != NULL){
			string key(param);
			// second parameter: value string to match
			if(session->save_pointer != NULL){
				string value(session->save_pointer);
				
				// search players
				for(i = 0; i < gLockedMem->inBus; i++){
					pLocks[i]->readLock(true);
					instance = gLockedMem->pList[i];
					if((instance != NULL) && instance->UID){
						if(GetMetaData(instance->UID, key) == value){
							uid = instance->UID;
							pLocks[i]->readUnlock();
							break;
						}
					}
					pLocks[i]->readUnlock();
				}
				
				if(uid == 0){
					// search list
					lMutex->readLock(true);
					for(i=0; i<(signed)PlayList.size(); i++){
						instance = PlayList.at(i);
						if((instance != NULL) && instance->UID){
							if(GetMetaData(instance->UID, key) == value){
								uid = instance->UID;
								break;
							}
						}
					}
					lMutex->readUnlock();
				}
			}	
			
			tx_length = snprintf(buf, sizeof buf, "%08x\n", uid);
			my_send(session->cs, buf, tx_length, session->silent);
			session->lastUID = uid;
			return rOK; 
		}
	}
	session->lastUID = 0;
	session->errMSG = "Missing or bad parameter\n";
	return rError;
}

unsigned char handle_inuid(ctl_session *session)
{
	char buf[16]; /* send data buffer */
    int tx_length;
    input_map_ptr dp;
	metaDataPtr Data;
	AudioDeviceID thisDevID;
	int i, j;
	ARPlayer *instance;
	InputPlayer *iplayer;
	uint32_t uid;
	
	// search for the specified input in the players, then in the playlist queue
	uid = 0;
	if(session->save_pointer != NULL){
		string name(session->save_pointer);
		// get input definition by name
		pthread_mutex_lock( &iMutex );
	    dp = inputMap.find(name);
		if(dp != inputMap.end()){
			// found... 
			thisDevID = GetDeviceID((*dp).second->deviceUID.c_str());
			// make sure this same input is not already loaded
			for(i = 0; i < gLockedMem->inBus; i++){
				pLocks[i]->readLock(true);
				instance = gLockedMem->pList[i];
				if(instance != NULL){
					if(strcmp(instance->type, pType_input_device) == 0){
						// it's an input
						iplayer = (InputPlayer*)instance;
						if(iplayer->devID == thisDevID){
							// audio device ID's match
							for(j=0; i<chanWidth; j++){
								if(iplayer->chanMap[j] != (*dp).second->channelMap[j]) 
									break;
							}
							if(j == chanWidth){
								pLocks[i]->readUnlock();
								uid = iplayer->UID;
								break;
							}
						}
					}
				}
				pLocks[i]->readUnlock();
			}
			pthread_mutex_unlock( &iMutex );
			
			if(uid == 0){
				// search list
				lMutex->readLock(true);
				for(i=0; i<(signed)PlayList.size(); i++){
					dMutex->readLock(true);
					instance = PlayList.at(i);
					if(instance){
						Data = metaList[instance->UID];
						if(Data){
							if(GetMetaData(instance->UID, "URL") == string("input:///" + name)){
								uid = instance->UID;
								dMutex->readUnlock();
								break;
							}
						}
					}
					dMutex->readUnlock();
				}
				lMutex->readUnlock();
			}

			tx_length = snprintf(buf, sizeof buf, "%08x\n", uid);
			my_send(session->cs, buf, tx_length, session->silent);
			session->lastUID = uid;
			return rOK; 
		}
		pthread_mutex_unlock( &iMutex );
	}
	session->lastUID = 0;
	session->errMSG = "Missing or bad parameter\n";
	return rError;
}

unsigned char handle_back(ctl_session *session)
{
	char *param;
	uint32_t aInt;
	ARPlayer *instance;

	// first parameter, player number
	param = strtok_r(nil, " ", &session->save_pointer);
	if(param != nil){
		aInt = atoi(param);
		if(!checkPnumber(aInt)){
			session->errMSG = "Bad player number.\n";
			return rError;            
		}
		if(pLocks[aInt]->readLock(false)){
			instance = gLockedMem->pList[aInt];
			if(instance != NULL){
				instance->skipback();
				pLocks[aInt]->readUnlock();
				return rOK;
			}
			pLocks[aInt]->readUnlock();
		}else{
			session->errMSG = "Player is busy.\n";
			return rError;
		}
	}
	session->errMSG = "Missing parameter.\n";
	return rError;
}

unsigned char handle_ahead(ctl_session *session)
{
	char *param;
	uint32_t aInt;
	ARPlayer *instance;

	// first parameter, player number
	param = strtok_r(nil, " ", &session->save_pointer);
	if(param != nil){
		aInt = atoi(param);
		if(!checkPnumber(aInt)){
			session->errMSG = "Bad player number.\n";
			return rError;            
		}
		if(pLocks[aInt]->readLock(false)){
			instance = gLockedMem->pList[aInt];
			if(instance != NULL){
				instance->skipahead();
				pLocks[aInt]->readUnlock();
				return rOK;
			}
			pLocks[aInt]->readUnlock();
		}else{
			session->errMSG = "Player is busy.\n";
			return rError;
		}
	}
	session->errMSG = "Missing parameter.\n";
	return rError;
}

unsigned char handle_rstat(ctl_session *session)
{
	char buf[4096]; /* send data buffer */
    int tx_length;
	uint32_t i;
	string result;
	Recorder *rec;
	int status;
	
	// recorders status
	tx_length = snprintf(buf, sizeof buf, "encoder\t\tstatus\ttime\tlimit\tdelay\tgain\tname\n");
	my_send(session->cs, buf, tx_length, session->silent);
	rMutex->readLock(true);
	for(i=0; i<RecList.size(); i++){
		rec = RecList.at(i);
		status = rec->status & ~(rec_locked);
		if(rec->locked)
			status = status | rec_locked;
		tx_length = snprintf(buf, sizeof buf, "%08x\t%d\t%.1f\t%.1f\t%.1f\t%.3f\t%s\n", (unsigned int)rec->UID, status, rec->RecordTime, rec->t_limit, rec->GetDelay(), rec->volume, GetMetaData(rec->UID, string("Name")).c_str());
		my_send(session->cs, buf, tx_length, session->silent);
	}
	rMutex->readUnlock();
	return rNone;
}

unsigned char handle_setstat(ctl_session *session)
{
	char *param;
	ARPlayer *instance;
	uint32_t aInt;
	uint32_t bInt;

	// first parameter, player number
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		aInt = atoi(param);
		if(!checkPnumber(aInt)){
			session->errMSG = "Bad player number.\n";
			return rError	;
		}
		// second parameter, status word
		param = strtok_r(NULL, " ", &session->save_pointer);
		if(param != NULL){
			bInt = atoi(param);
			if(pLocks[aInt]->readLock(false)){
				instance = gLockedMem->pList[aInt];
				if(instance != NULL){
					instance->setStatus(bInt);
					pLocks[aInt]->readUnlock();
					return rOK;
				}
				pLocks[aInt]->readUnlock();
			}else{
				session->errMSG = "Player is busy.\n";
				return rError;
			}
		}
	}
	session->errMSG = "Missing parameter.\n";
	return rError;
}

unsigned char handle_feed(ctl_session *session)
{
	char *param;
	int sInt;
	uint32_t aInt;
	uint32_t bInt;
	float aFloat;
	ARPlayer *instance;

	// first parameter, player number
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		aInt = atoi(param);
		if(!checkPnumber(aInt)){
			session->errMSG = "Bad player number.\n";
			return rError;
		}
		// second parameter, set feed to output mix bus number, or -1 to ignore bus
		param = strtok_r(NULL, " ", &session->save_pointer);
		if(param != NULL){
			sInt = atoi(param);
			if(sInt < 0)
				bInt = 0xffffffff;
			else
				bInt = sInt;
			// third parameter (optional), feed volume
			param = strtok_r(NULL, " ", &session->save_pointer);
			if(param != NULL){
				aFloat = atof(param);
			}else{
				aFloat = -1;
			}
			if(pLocks[aInt]->readLock(false)){
				instance = gLockedMem->pList[aInt];
				if(instance != NULL){
					instance->setFeed(bInt, aFloat);
					pLocks[aInt]->readUnlock();
					return rOK;
				}
				pLocks[aInt]->readUnlock();
			}else{
				session->errMSG = "Player is busy.\n";
				return rError;
			}
		}
	}
	session->errMSG = "Missing parameter.\n";
	return rError;
}

unsigned char handle_delete(ctl_session *session)
{
	char *param;
	char *end;
	uint32_t aLong;
	int sInt;

	// first parameter, position or UID
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		lMutex->writeLock(true, "handle_delete");
		if(strlen(param) > 4){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
			session->lastUID = aLong;
			if(!getListPos(&aLong)){
				lMutex->writeUnlock();
				session->errMSG = "Specified UID is not in play list.\n";
				return rError	;
			}
			sInt = (int)aLong;
		}else{
			// decimal number (list index)
			sInt = atoi(param);
		}
		DeleteItem(sInt);
		lMutex->writeUnlock();
		return rOK;
	}
	session->errMSG = "Missing parameter.\n";
	return rError;
}

unsigned char handle_move(ctl_session *session)
{
	char *param;
	char *end;
	int aInt;
	int bInt;
	uint32_t uLong;

	// first parameter, old position
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		lMutex->writeLock(true, "handle_move");
		if(strlen(param) > 4){
			// hex number (UID)
			uLong = strtoul(param, &end, 16);
			if(!getListPos(&uLong)){
				lMutex->writeUnlock();
				session->errMSG = "Move from UID not in play list.\n";
				return rError;
			}
			aInt = (int)uLong;
		}else{
			// decimal number (pNum)
			aInt = atoi(param);
		}

		// second parameter, new position (-1 for end of list)
		param = strtok_r(NULL, " ", &session->save_pointer);
		if(param != NULL){
			if(strlen(param) > 4){
				// hex number (UID)
				uLong = strtoul(param, &end, 16);
				if(!getListPos(&uLong)){
					lMutex->writeUnlock();
					session->errMSG = "Move to UID not in play list.\n";
					return rError;
				}
				bInt = (int)uLong;
			}else{
				// decimal number (pNum)
				bInt = atoi(param);
			}
			MoveItem(aInt, bInt, true);
			lMutex->writeUnlock();
			return rOK;
		}
		lMutex->writeUnlock();
	}
	session->errMSG = "Missing parameter.\n";
	return rError;
}

unsigned char handle_add(ctl_session *session)
{
	char *param;
	char *end;
	char buf[4096]; /* send data buffer */
    uint32_t aLong;
	int aInt;
    int bInt;
    int tx_length;

	// first parameter, position (-1 for end of list) or UID
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		lMutex->writeLock(true, "handle_add");
		if(strlen(param) > 4){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
			if(!getListPos(&aLong)){
				lMutex->writeUnlock();
				session->errMSG = "Insertion point UID is not in play list.\n";
				return rError;
			}
			aInt = (int)aLong;
		}else{
			// decimal number (position)
			aInt = atoi(param);
			if(aInt == -2){
				// add at the position of the current next item to play
				aInt = GetNextSegListPos(NULL);
			}
		}
		// second parameter, URL or preloaded player number to add
		if(session->save_pointer != NULL){
			if(isdigit(*session->save_pointer)){
				// second param: player number
				bInt = atoi(session->save_pointer);
				if(!checkPnumber(bInt)){
					session->errMSG = "Bad player number.\n";
					lMutex->writeUnlock();
					return rError;            
				}
				AddPlayer(aInt, bInt);
				lMutex->writeUnlock();
				return rOK;

			}else{
				// Second Param: URL
				aLong = AddItem(aInt, session->save_pointer, "", 0);
				if(aLong){
					session->lastUID = aLong;
					tx_length = snprintf(buf, sizeof buf, "UID=%08x\n", (unsigned int)aLong);
					my_send(session->cs, buf, tx_length, session->silent);
					lMutex->writeUnlock();
					return rNone;
				}
			}
		}
		lMutex->writeUnlock();
	}
	session->errMSG = "Missing parameter.\n";
	return rError;
}

unsigned char handle_uadd(ctl_session *session)
{
	ARPlayer *instance;
	char *param;
	char *end;
	char buf[4096]; /* send data buffer */
    uint32_t aLong;
	int aInt;
	unsigned int i;
    int tx_length;
	
	// first parameter, position (-1 for end of list) or UID
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		lMutex->writeLock(true, "handle_uadd");
		if(strlen(param) > 4){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
			if(!getListPos(&aLong)){
				lMutex->writeUnlock();
				session->errMSG = "Insertion point UID is not in play list.\n";
				return rError;
			}
			aInt = (int)aLong;
		}else{
			// decimal number (position)
			aInt = atoi(param);
			if(aInt == -2){
				// add at the position of the current next item to play
				aInt = GetNextSegListPos(NULL);
			}
		}
		// second parameter, URL
		if(session->save_pointer != NULL){
			// search to see if it's already in the list
			aLong = 0;
			for(i=0; i<PlayList.size(); i++){
				instance = PlayList.at(i);
				if((instance != NULL) && instance->UID){
					if(GetMetaData(instance->UID, "URL") == string(session->save_pointer)){
						aLong = instance->UID;
						break;
					}
				}
			}
			if(aLong == 0)			
				// not already in the list... add it
				aLong = AddItem(aInt, session->save_pointer, "", 0);
			if(aLong){
				session->lastUID = aLong;
				tx_length = snprintf(buf, sizeof buf, "UID=%08x\n", (unsigned int)aLong);
				my_send(session->cs, buf, tx_length, session->silent);
				lMutex->writeUnlock();
				return rNone;
			}
		}
		lMutex->writeUnlock();
	}
	session->errMSG = "Missing parameter.\n";
	return rError;
}

unsigned char handle_split(ctl_session *session)
{
	char *param;
	char *end;
	char buf[4096]; /* send data buffer */
    uint32_t aLong;
	int tx_length;

	// first parameter, uid of list item to split
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		if(strlen(param) > 2){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
		}else{
			// assume we want the last UID used in this session
			aLong = session->lastUID;
		}
		// second parameter, URL for split child
		if(session->save_pointer != NULL){
			// Second Param: URL
			aLong = SplitItem(aLong, session->save_pointer);
			if(aLong){
				session->lastUID = aLong;
				tx_length = snprintf(buf, sizeof buf, "UID=%08x\n", (unsigned int)aLong);
				my_send(session->cs, buf, tx_length, session->silent);
				return rNone;
			}
		}
	}
	session->errMSG = "Missing parameter.\n";
	return rError;
}

unsigned char handle_waitseg(ctl_session *session)
{
	char *param;
	char *end;
    uint32_t aLong;
	uint32_t pos;
	int next;
	int sInt;
	
	// first parameter, metadata item UID in hex format of the list item beyond 
	// which any item that the list starts playing will break the wait loop
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		if(strlen(param) > 2){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
		}else{
			// decimal number (pNum)
			sInt = atoi(param);
			if(sInt < 0){
				aLong = session->lastUID;
			}else{
				aLong = (uint32_t)sInt;
				if(!getPlayerUID(&aLong)){
					session->errMSG = "Bad player number.\n";
					return rError;
				}
			}
		}
		
		pthread_mutex_lock( &lastsegMutex );
		while(run){
			pthread_cond_wait( &lastsegSemaphore, &lastsegMutex );
			lMutex->readLock(true);
			next = GetNextSegListPos(NULL);
			pos = aLong;
			if(!getListPos(&pos) || ((unsigned)next > pos)){
				// break out of wait loop
				lMutex->readUnlock();
				break;
			}
			lMutex->readUnlock();
		}
		pthread_mutex_unlock(&lastsegMutex);
	}else{
		session->errMSG = "Missing parameter.\n";
		return rError;
	}
	return rNone;
}

unsigned char handle_segnow(ctl_session *session)
{
	int thisPlayer;
	ARPlayer *instance;

	lMutex->readLock(true);
	GetNextSegListPos(&thisPlayer);
	lMutex->readUnlock();
	if(checkPnumber(thisPlayer)){
		if(pLocks[thisPlayer]->readLock(false)){
			instance = gLockedMem->pList[thisPlayer];
			if(instance != NULL){
				instance->fade = instance->position;
				pLocks[thisPlayer]->readUnlock();
				return rOK;
			}
			pLocks[thisPlayer]->readUnlock();
		}else{
			session->errMSG = "Player is busy.\n";
			return rError;
		}
	}
	session->errMSG = "Nothing cued next.\n";
	return rError;
}

unsigned char handle_segall(ctl_session *session)
{
	ARPlayer *instance;
	int i;

	// search all players, fade items that are found to be playing and managed
	for(i = 0; i < gLockedMem->inBus; i++){
		pLocks[i]->readLock(true);
		instance = gLockedMem->pList[i];
		if((instance != NULL) && ((instance->status & status_playing) != 0) && ((instance->status & status_cueing) == 0) && instance->Managed){
			// currently playing and not in cue... fade it!
			instance->fade = instance->position;
		}
		pLocks[i]->readUnlock();
	}
	return rOK;
}

unsigned char handle_fadeprior(ctl_session *session)
{
	int i, count;
	ARPlayer *instance;
	
	lMutex->readLock(true);
	count = PlayList.size();
	if(count > gLockedMem->inBus)
		count = gLockedMem->inBus;
	i = count;
	while(--i >= 0){
		instance = PlayList.at(i);
		if(instance != NULL){
			if(instance->status & status_hasPlayed){
				// this is the most recent playing list item
				// don't fade this one, but keep going back and fade earlier items in players
				while(--i >= 0){
					if((instance = PlayList.at(i)) && checkPnumber(instance->pNum)){
						pLocks[instance->pNum]->readLock(true);
						if(((instance->status & status_playing) != 0) && ((instance->status & status_cueing) == 0) && instance->Managed){
							// currently playing and not in cue... fade it!
							instance->next = -1;
							instance->fade = instance->position;
						}
						pLocks[instance->pNum]->readUnlock();
					}
				}
				break;
			}
		}
	}
	lMutex->readUnlock();
	return rOK;
}

unsigned char handle_expand(ctl_session *session)
{
	char *param;
	char *end;
    uint32_t aLong, pos;
	ARPlayer *instance;

	// first parameter, uid of list item to split
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		if(strlen(param) > 2){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
		}else{
			// assume we want the last UID used in this session
			aLong = session->lastUID;
		}
		lMutex->readLock(true);
		pos = aLong;
		if(!getListPos(&pos)){
			lMutex->readUnlock();
			session->errMSG = "item is not in play list.\n";
			return rError;
		}
		if(instance = PlayList.at(pos)){
			if(!strcmp(instance->type, pType_db_pl) || !strcmp(instance->type, pType_file_pl)){
				// it's a playlist
				session->lastUID = aLong;
				plTaskRunner(aLong);
				lMutex->readUnlock();
				return rNone;
			}
			session->errMSG = "Item is not a playlist.\n";
		}else
			session->errMSG = "Bad UID number.\n";
		lMutex->readUnlock();
	}else
		session->errMSG = "Missing parameter.\n";
	return rError;
}

unsigned char handle_newrec(ctl_session *session)
{
	Recorder *rec;
	char buf[4096]; /* send data buffer */
    int tx_length;

	rec = new Recorder;
	rec->UID = createMetaRecord("", NULL);
	registerMetaUser(rec->UID);
	session->lastUID = rec->UID;
	// add recorder instance to end of recorder list
	vector<Recorder*>::iterator lp;
	rMutex->writeLock(true, "handle_newrec");
	lp = RecList.end();
	RecList.insert(lp, rec); 
	rMutex->writeUnlock();
	session->lastUID = rec->UID;
	tx_length = snprintf(buf, sizeof buf, "UID=%08x\n", (unsigned int)rec->UID);
	my_send(session->cs, buf, tx_length, session->silent);

	struct notifyData	data;
	data.reference = EndianS32_NtoB(rec->UID);
	data.senderID = getSenderID();
	data.value.iVal = EndianS32_NtoB(0);
	Notifier->MakeEntry(nType_rstat, &data, sizeof(data), -1);						

	return rNone;
}

unsigned char handle_initrec(ctl_session *session)
{
	char *param;
	char *end;
	Recorder *rec;
	uint32_t aLong;

	// first parameter, meta data item UID in hex format
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		if(strlen(param) > 2){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
		}else{
			// assume we want the last UID used in this session
			aLong = session->lastUID;
		}
		rMutex->readLock(true);
		// make sure this is has a unique name
		for(uint32_t idx=0; idx<RecList.size(); idx++){
			rec = RecList.at(idx);
			if(GetMetaData(rec->UID, "Name") == GetMetaData(aLong, "Name")){
				if(rec->UID != aLong){
					// It's a dupe.  Fail!
					rMutex->readUnlock();
					session->lastUID = aLong;
					session->errMSG = "Duplicate recorder name.\n";
					return rError;
				}
			}
		}
		for(uint32_t idx=0; idx<RecList.size(); idx++){
			rec = RecList.at(idx);
			if(rec->UID == aLong){
				// UID matched the first parameter
				if(rec->locked == TRUE){
					// It's locked.  Fail!
					rMutex->readUnlock();
					session->lastUID = aLong;
					session->errMSG = "Recorder is locked.\n";
					return rError;
				}
				if(rec->init()){
					rMutex->readUnlock();
					session->lastUID = aLong;
					return rOK;
				}
				rMutex->readUnlock();
				session->errMSG = "Recorder failed to initialize: check metadata settings.\n";
				return rError;
			}
		}
		rMutex->readUnlock();
	}
	session->lastUID = 0;
	session->errMSG = "Missing parameter.\n";
	return rError;
}

unsigned char handle_startrec(ctl_session *session)
{
	char *param;
	char *end;
	Recorder *rec;
	uint32_t aLong;

	// first parameter, meta data item UID in hex format
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		if(strlen(param) > 2){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
		}else{
			// assume we want the last UID used in this session
			aLong = session->lastUID;
		}
		if(aLong != 0){
			rMutex->readLock(true);
			for(uint32_t idx=0; idx<RecList.size(); idx++){
					rec = RecList.at(idx);
					if(rec->UID == aLong){
						// UID matched the first parameter
						if(rec->locked == TRUE){
							// It's locked.  Fail!
							rMutex->readUnlock();
							session->lastUID = aLong;
							session->errMSG = "Recorder is locked.\n";
							return rError;
						}
						rec->start();
						rMutex->readUnlock();
						session->lastUID = aLong;
						return rOK;
					}
			}
			rMutex->readUnlock();
			session->lastUID = aLong;
			session->errMSG = "Bad recorder UID specified.\n";
			return rError;
		}
	}
	session->lastUID = 0;
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

unsigned char handle_stoprec(ctl_session *session)
{
	char *param;
	char *end;
	Recorder *rec;
	uint32_t aLong;

	// first parameter, meta data item UID in hex format
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		if(strlen(param) > 2){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
		}else{
			// assume we want the last UID used in this session
			aLong = session->lastUID;
		}
		if(aLong != 0){
			rMutex->readLock(true);
			for(uint32_t idx=0; idx<RecList.size(); idx++){
				rec = RecList.at(idx);
				if(rec->UID == aLong){
					if(rec->locked == TRUE){
						// It's locked.  Fail!
						rMutex->readUnlock();
						session->lastUID = aLong;
						session->errMSG = "Recorder is locked.\n";
						return rError;
					}						
					rec->stop();
					rMutex->readUnlock();
					session->lastUID = aLong;
					return rOK;
				}
			}
			rMutex->readUnlock();
			session->lastUID = aLong;
			session->errMSG = "Bad recorder UID specified.\n";
			return rError;
		}
	}
	session->lastUID = 0;
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

unsigned char handle_recgain(ctl_session *session)
{
	char *param;
	char *end;
	Recorder *rec;
	uint32_t aLong;
	float aFloat;

	// first parameter, meta data item UID in hex format
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		if(strlen(param) > 2){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
		}else{
			// assume we want the last UID used in this session
			aLong = session->lastUID;
		}
		if(aLong != 0){
			// second parameter, volume
			param = strtok_r(NULL, " ", &session->save_pointer);
			if(param != NULL){
				aFloat = atof(param);
				rMutex->readLock(true);
				for(uint32_t idx=0; idx<RecList.size(); idx++){
						rec = RecList.at(idx);
						if(rec->UID == aLong){
							// UID matched the first parameter
							if(rec->locked == TRUE){
								// It's locked.  Fail!
								rMutex->readUnlock();
								session->lastUID = aLong;
								session->errMSG = "Recorder is locked.\n";
								return rError;
							}
							rec->setVol(aFloat);
							rMutex->readUnlock();
							session->lastUID = aLong;
							return rOK;
						}
				}
			}
			rMutex->readUnlock();
			session->lastUID = aLong;
			session->errMSG = "BMissing parameter.\n";
			return rError;
		}
		rMutex->readUnlock();
		session->lastUID = aLong;
		session->errMSG = "Bad recorder UID specified.\n";
		return rError;
	}
	session->lastUID = 0;
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

unsigned char handle_lockrec(ctl_session *session)
{
	char *param;
	char *end;
	Recorder *rec;
	uint32_t aLong;

	// first parameter, meta data item UID in hex format
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		if(strlen(param) > 2){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
		}else{
			// assume we want the last UID used in this session
			aLong = session->lastUID;
		}
		if(aLong != 0){
			rMutex->readLock(true);
			for(uint32_t idx=0; idx<RecList.size(); idx++){
				rec = RecList.at(idx);
				if(rec->UID == aLong){
					rec->setLocked(TRUE);
					rMutex->readUnlock();
					session->lastUID = aLong;
					
					struct notifyData	data;
					data.reference = EndianS32_NtoB(aLong);
					data.senderID = getSenderID();
					data.value.iVal = EndianS32_NtoB(0);
					Notifier->MakeEntry(nType_rstat, &data, sizeof(data), -1);						

					return rOK;
				}
			}
			rMutex->readUnlock();
			session->lastUID = aLong;
			session->errMSG = "Bad recorder UID specified.\n";
			return rError;
		}
	}
	session->lastUID = 0;
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

unsigned char handle_unlockrec(ctl_session *session)
{
	char *param;
	char *end;
	Recorder *rec;
	uint32_t aLong;

	// first parameter, meta data item UID in hex format
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		if(strlen(param) > 2){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
		}else{
			// assume we want the last UID used in this session
			aLong = session->lastUID;
		}
		if(aLong != 0){
			rMutex->readLock(true);
			for(uint32_t idx=0; idx<RecList.size(); idx++){
				rec = RecList.at(idx);
				if(rec->UID == aLong){
					rec->setLocked(FALSE);
					rMutex->readUnlock();
					session->lastUID = aLong;
					
					struct notifyData	data;
					data.reference = EndianS32_NtoB(aLong);
					data.senderID = getSenderID();
					data.value.iVal = EndianS32_NtoB(0);
					Notifier->MakeEntry(nType_rstat, &data, sizeof(data), -1);								
					
					return rOK;
				}
			}
			rMutex->readUnlock();
			session->lastUID = aLong;
			session->errMSG = "Bad recorder UID specified.\n";
			return rError;
		}
	}
	session->lastUID = 0;
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

unsigned char handle_closerec(ctl_session *session)
{
	char *param;
	char *end;
	Recorder *rec;
	uint32_t aLong;
	
	// first parameter, meta data item UID in hex format
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		if(strlen(param) > 2){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
		}else{
			// assume we want the last UID used in this session
			aLong = session->lastUID;
		}
		if(aLong != 0){
			rMutex->writeLock(true, "handle_closerec");
			for(uint32_t idx=0; idx<RecList.size(); idx++){
				rec = RecList.at(idx);
				if(rec->UID == aLong){
					if(rec->locked == TRUE){
						// It's locked.  Fail!
						rMutex->writeUnlock();
						session->lastUID = aLong;
						session->errMSG = "Recorder is locked.\n";
						return rError;
					}
					vector<Recorder*>::iterator lp = RecList.begin();
					advance(lp, idx);
					RecList.erase(lp);
					delete rec;
				}
			}
			rMutex->writeUnlock();
			session->lastUID = aLong;

			struct notifyData	data;
			data.reference = EndianS32_NtoB(aLong);
			data.senderID = getSenderID();
			data.value.iVal = EndianS32_NtoB(0);
			Notifier->MakeEntry(nType_rstat, &data, sizeof(data), -1);						

			return rOK;
		}
	}
	session->lastUID = 0;
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

unsigned char handle_debugrec(ctl_session *session)
{
	uint32_t i;
	int count;
	char *param;
	char *end;
	uint32_t aLong;
	Recorder *rec;
	
	// first parameter, meta data item UID in hex format, or zero for all, or -1 for lastUid
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		if(strlen(param) > 2){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
		}else{
			// decimal intereger number (zero or -1)
			if((aLong = atoi(param)) < 0)
				// assume we want the last UID used in this session
				aLong = session->lastUID;
			else 
				// assume we want send to all running RSP encoders
				aLong = 0;
		}
		count = 0;
		rMutex->readLock(true);
		for(i=0; i<RecList.size(); i++){
			rec = RecList.at(i);
			if(!aLong){
				if(rec->debug())
					count++;
				continue;
			}
			if(rec->UID == aLong){
				if(rec->debug()){
					count++;
					session->lastUID = aLong;
					break;
				}
			}
		}
		rMutex->readUnlock();
		if(count)
			return rOK;
		session->errMSG = "No running RSP encoders\n";
		return rError;
	}
	session->errMSG = "Missing or bad parameter.\n";
	return rError;	
}


unsigned char handle_jsonpost(ctl_session *session)
{
	uint32_t i;
	int count;
	char *param;
	char *end;
	uint32_t aLong;
	Recorder *rec;
	
	// first parameter, meta data item UID in hex format, or zero for all, or -1 for lastUid
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		if(strlen(param) > 2){
			// hex number (UID)
			aLong = strtoul(param, &end, 16);
		}else{
			// decimal intereger number (zero or -1)
			if((aLong = atoi(param)) < 0)
				// assume we want the last UID used in this session
				aLong = session->lastUID;
			else 
				// assume we want send to all running RSP encoders
				aLong = 0;
		}
		// second parameter, json object in non-printable (no LF/CR) text format to queue into rsp streamers
		count = 0;
		if(session->save_pointer){
			rMutex->readLock(true);
			for(i=0; i<RecList.size(); i++){
				rec = RecList.at(i);
				if(!aLong){
					if(rec->queueJSON(session->save_pointer))
						count++;
					continue;
				}
				if(rec->UID == aLong){
					if(rec->queueJSON(session->save_pointer)){
						count++;
						session->lastUID = aLong;
						break;
					}
				}
			}
			rMutex->readUnlock();
			if(count)
				return rOK;
			session->errMSG = "No running RSP encoders or bad json string.\n";
			return rError;
		}
	}
	session->errMSG = "Missing or bad parameter.\n";
	return rError;	
}

unsigned char handle_fxcue(ctl_session *session)
{
	char *param;
	char *end;
	char type, bus;
	Recorder *r;
	ARPlayer *p;
	AUManager *aum;
	uint32_t aLong;
	output_map_ptr dp;
	uint32_t i;
	
	// first parameter, UID in hex format
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param == NULL){
		// no UID specified... remove current fx chain from cue mode, if any
		gLockedMem->cueInsertPtr = NULL;
		gLockedMem->cueInsertTime = 0;
		gLockedMem->cueChanCount = 0;
		struct notifyData	data;
		data.senderID = getSenderID();
		data.reference = 0;
		data.value.iVal = 0;
		Notifier->MakeEntry(nType_fxcue, &data, sizeof(data), -1);
		return rOK;
	}else{
		if(strlen(param) > 2){
			// hex number (UID/OID)
			aLong = strtoul(param, &end, 16);
		}else{
			if(atoi(param) < 0)		
				aLong = session->lastUID;					// -1: use lastUID
			else					
				aLong = (uint32_t)atoi(param) | 0x80000000;	// player number
		}	
		type = (aLong & 0xf0000000) >> 28;
		aLong = aLong & 0xf00fffff;
		// second parameter, bus number
		if(session->save_pointer){
			bus = atoi(session->save_pointer);
			switch(type){
				case 0x00:
					// UID, player or recorder
					
					// first search recorder list
					rMutex->readLock(true);
					for(i=0; i<RecList.size(); i++){
						r = RecList.at(i);
						if(r->UID == aLong){
							if(r->locked == TRUE){
								// It's locked.  Fail!
								rMutex->readUnlock();
								session->errMSG = "Recorder is locked.\n";
								return rError;
							}
							if(aum = (AUManager*)r->getAUManager(bus)){
								gLockedMem->cueInsertPtr = NULL;
								sleep(1);
								gLockedMem->cueInsertTime = 0;
								gLockedMem->cueChanCount = 0;
								gLockedMem->cueInsertPtr = (void *)aum;
								rMutex->readUnlock();
								struct notifyData	data;
								data.senderID = getSenderID();
								data.reference = EndianS32_NtoB(aLong);
								data.value.iVal = EndianS32_NtoB((signed int)bus);
								Notifier->MakeEntry(nType_fxcue, &data, sizeof(data), -1);
								return rOK;										
							}
						}
					}
					rMutex->readUnlock();
					
					// next search player list
					for(i=0; i<gLockedMem->inBus; i++){
						pLocks[i]->readLock(true);
						p = gLockedMem->pList[i];
						if((p != NULL) && (p->UID == aLong)){
							if(aum = (AUManager*)p->getAUManager(bus)){
								gLockedMem->cueInsertPtr = NULL;
								sleep(1);
								gLockedMem->cueInsertTime = 0;
								gLockedMem->cueInsertPtr = (void *)aum;
								pLocks[i]->readUnlock();
								struct notifyData	data;
								data.senderID = getSenderID();
								data.reference = EndianS32_NtoB(aLong);
								data.value.iVal = EndianS32_NtoB((signed int)bus);
								Notifier->MakeEntry(nType_fxcue, &data, sizeof(data), -1);
								return rOK;
							}
						}
						pLocks[i]->readUnlock();
					}
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;
					
				case 0x0c:
					// output AID
					pthread_mutex_lock(&oMutex);
					for(dp=outputMap.begin(); dp!=outputMap.end(); dp++){
						if((*dp).second->OID == (aLong & 0xf00fffff)){
							if(aum = (AUManager*)(*dp).second->getAUManager(bus)){
								gLockedMem->cueInsertPtr = NULL;
								sleep(1);
								gLockedMem->cueInsertTime = 0;
								gLockedMem->cueInsertPtr = (void *)aum;
								pthread_mutex_unlock(&oMutex);
								struct notifyData	data;
								data.senderID = getSenderID();
								data.reference = EndianS32_NtoB(aLong);
								data.value.iVal = EndianS32_NtoB((signed int)bus);
								Notifier->MakeEntry(nType_fxcue, &data, sizeof(data), -1);
								return rOK;
							}
						}
					}
					pthread_mutex_unlock(&oMutex);
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;
											
				case 0x08:
					// player number AID				
					i = aLong & 0x000000ff;
					if(!checkPnumber(i)){
						session->errMSG = "Bad player number.\n";
						return rError;            
					}
					pLocks[i]->readLock(true);
					p = gLockedMem->pList[i];
					if(p != NULL){
						if(aum = (AUManager*)p->getAUManager(bus)){
							gLockedMem->cueInsertPtr = NULL;
							sleep(1);
							gLockedMem->cueInsertTime = 0;
							gLockedMem->cueInsertPtr = (void *)aum;
							pLocks[i]->readUnlock();
							struct notifyData	data;
							data.senderID = getSenderID();
							data.reference = EndianS32_NtoB(aLong);
							data.value.iVal = EndianS32_NtoB((signed int)bus);
							Notifier->MakeEntry(nType_fxcue, &data, sizeof(data), -1);
							return rOK;
						}
					}
					pLocks[i]->readUnlock();
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;
				
				default:
					session->errMSG = "Unknown AudioUint ID parent type\n";
					return rError;		
			}
		}
	}
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

unsigned char handle_fxlist(ctl_session *session)
{
	char buf[4096]; /* send data buffer */
    int tx_length;

	if(!session->silent){
		tx_length = snprintf(buf, sizeof buf, "Subtype\tMfgCode\tName\n");
		my_send(session->cs, buf, tx_length, session->silent);
		DumpAUList(session->cs, buf, sizeof buf);
	}
	return rNone;
}

unsigned char handle_fxslots(ctl_session *session)
{
	char *param;
	char *end;
	char type, bus;
	Recorder *r;
	ARPlayer *p;
	AUManager *aum;
	uint32_t aLong;
	char buf[4096];
	string str;
	const char *cstr;
	output_map_ptr dp;
    int tx_length;
	uint32_t i;
	
	// first parameter, UID in hex format
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		if(strlen(param) > 2){
			// hex number (UID/OID)
			aLong = strtoul(param, &end, 16);
		}else{
			if(atoi(param) < 0)		
				aLong = session->lastUID;									// -1: use lastUID
			else					
				aLong = (uint32_t)atoi(param) | 0x80000000;	// player number
		}	
		type = (aLong & 0xf0000000) >> 28;
		aLong = aLong & 0xf00fffff;
		// second parameter, bus number
		if(session->save_pointer){
			bus = atoi(session->save_pointer);
			switch(type){
				case 0x00:
					// AID is a UID, player or recorder
					
					// first search recorder list
					rMutex->readLock(true);
					for(i=0; i<RecList.size(); i++){
						r = RecList.at(i);
						if(r->UID == aLong){
							if(r->locked == TRUE){
								// It's locked.  Fail!
								rMutex->readUnlock();
								session->errMSG = "Recorder is busy.\n";
								return rError;
							}
							if(aum = (AUManager*)r->getAUManager(bus)){
								str = aum->list();
								if(cstr = str.c_str()){
									if(gLockedMem->cueInsertPtr == (void *)aum)
										tx_length = snprintf(buf, sizeof buf, "cue=1\n");
									else
										tx_length = snprintf(buf, sizeof buf, "cue=0\n");
									my_send(session->cs, buf, tx_length, session->silent);									
									tx_length = snprintf(buf, sizeof buf, "slot\trev\tbypass\tsubtype\tmfg\tname\n");
									my_send(session->cs, buf, tx_length, session->silent);
									my_send(session->cs, cstr, strlen(cstr), session->silent);
									rMutex->readUnlock();
									
									return rNone;
								}
							}
						}
					}
					rMutex->readUnlock();
					
					// next search player list
					for(i=0; i<gLockedMem->inBus; i++){
						pLocks[i]->readLock(true);
						p = gLockedMem->pList[i];
						if((p != NULL) && (p->UID == aLong)){
							if(aum = (AUManager*)p->getAUManager(bus)){
								str = aum->list();
								if(cstr = str.c_str()){
									if(gLockedMem->cueInsertPtr == (void *)aum)
										tx_length = snprintf(buf, sizeof buf, "cue=1\n");
									else
										tx_length = snprintf(buf, sizeof buf, "cue=0\n");
									my_send(session->cs, buf, tx_length, session->silent);									
									tx_length = snprintf(buf, sizeof buf, "slot\trev\tbypass\tsubtype\tmfg\tname\n");
									my_send(session->cs, buf, tx_length, session->silent);
									my_send(session->cs, cstr, strlen(cstr), session->silent);
									pLocks[i]->readUnlock();
									return rNone;
								}
							}
						}
						pLocks[i]->readUnlock();
					}
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;
					
				case 0x0c:
					// output AID
					pthread_mutex_lock(&oMutex);
					for(dp=outputMap.begin(); dp!=outputMap.end(); dp++){
						if((*dp).second->OID == aLong ){
							if(aum = (AUManager*)(*dp).second->getAUManager(bus)){
								str = aum->list();
								if(cstr = str.c_str()){
									if(gLockedMem->cueInsertPtr == (void *)aum)
										tx_length = snprintf(buf, sizeof buf, "cue=1\n");
									else
										tx_length = snprintf(buf, sizeof buf, "cue=0\n");
									my_send(session->cs, buf, tx_length, session->silent);									
									tx_length = snprintf(buf, sizeof buf, "slot\trev\tbypass\tsubtype\tmfg\tname\n");
									my_send(session->cs, buf, tx_length, session->silent);
									my_send(session->cs, cstr, strlen(cstr), session->silent);
									pthread_mutex_unlock(&oMutex);
									return rNone;
								}
							}
						}
					}
					pthread_mutex_unlock(&oMutex);
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;
											
				case 0x08:
					// player number AID				
					i = aLong & 0x000000ff;
					if(!checkPnumber(i)){
						session->errMSG = "Bad player number.\n";
						return rError;            
					}
					pLocks[i]->readLock(true);
					p = gLockedMem->pList[i];
					if(p != NULL){
						if(aum = (AUManager*)p->getAUManager(bus)){
							str = aum->list();
							if(cstr = str.c_str()){
								if(gLockedMem->cueInsertPtr == (void *)aum)
									tx_length = snprintf(buf, sizeof buf, "cue=1\n");
								else
									tx_length = snprintf(buf, sizeof buf, "cue=0\n");
								my_send(session->cs, buf, tx_length, session->silent);									
								tx_length = snprintf(buf, sizeof buf, "slot\trev\tbypass\tsubtype\tmfg\tname\n");
								my_send(session->cs, buf, tx_length, session->silent);
								my_send(session->cs, cstr, strlen(cstr), session->silent);
								pLocks[i]->readUnlock();
								return rNone;
							}
						}
					}
					pLocks[i]->readUnlock();
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;
				
				default:
					session->errMSG = "Unknown AudioUint ID parent type\n";
					return rError;		
			}
		}
	}
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

unsigned char handle_fxinsert(ctl_session *session)
{
	char *param, *sub, *mfg;
	char *end;
	char type;
	unsigned char slot, bus;
	Recorder *r;
	ARPlayer *p;
	AUManager *aum;
	output_map_ptr dp;
	uint32_t aLong;
	uint32_t i;
	
	// first parameter, AID in hex format
	if(param = strtok_r(NULL, " ", &session->save_pointer)){
		if(strlen(param) > 2){
			// hex number (UID/AID/OID)
			aLong = strtoul(param, &end, 16);
		}else{
			if(atoi(param) < 0)		
				aLong = session->lastUID;					// -1: use lastUID
			else					
				aLong = (uint32_t)atoi(param) | 0x80000000;	// player number
		}	
		type = (aLong & 0xf0000000) >> 28;
		aLong = aLong & 0xf00fffff;
		// second param is slot number
		if(param = strtok_r(NULL, " ", &session->save_pointer)){
			slot = atoi(param);
			// third param is bus number
			if(param = strtok_r(NULL, " ", &session->save_pointer)){
				bus = atoi(param);
				// fourth param is subtype string
				sub = strtok_r(NULL, " ", &session->save_pointer);
				// fifth param is mfg string
				mfg = session->save_pointer;
				switch(type){
					case 0x00:
						// AID is a UID, player or recorder
						
						// first search recorder list
						rMutex->readLock(true);
						for(i=0; i<RecList.size(); i++){
							r = RecList.at(i);
							if(r->UID == aLong){
								if(r->locked == TRUE){
									// It's locked.  Fail!
									rMutex->readUnlock();
									session->errMSG = "Recorder is locked.\n";
									return rError;
								}
								if(aum = (AUManager*)r->getAUManager(bus)){
									slot = aum->insert(slot, sub, mfg);
									if(slot != 0xff){
										rMutex->readUnlock();
										session->lastAID = aLong | ((uint32_t)slot << 24);
										// send out notifications
										struct notifyData	data;
										data.senderID = getSenderID();
										data.reference = EndianS32_NtoB(aLong);
										data.value.iVal = EndianS32_NtoB((signed int)bus);
										Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
										return rOK;
									}else{
										session->errMSG = "Audio Unit insert failed.\n";
										rMutex->readUnlock();
										return rError;
									}
								}
							}
						}
						rMutex->readUnlock();
						
						// next search player list
						for(i=0; i<gLockedMem->inBus; i++){
							pLocks[i]->readLock(true);
							p = gLockedMem->pList[i];
							if((p != NULL) && (p->UID == aLong)){
								if(aum = (AUManager*)p->getAUManager(bus)){
									slot = aum->insert(slot, sub, mfg);
									if(slot != 0xff){
										pLocks[i]->readUnlock();
										session->lastAID = aLong | ((uint32_t)slot << 24);
										// send out notifications
										struct notifyData	data;
										data.senderID = getSenderID();
										data.reference = EndianS32_NtoB(aLong);
										data.value.iVal = EndianS32_NtoB((signed int)bus);
										Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
										return rOK;
									}else{
										session->errMSG = "Audio Unit insert failed.\n";
										pLocks[i]->readUnlock();
										return rError;
									}
								}
							}
							pLocks[i]->readUnlock();
						}
						session->errMSG = "AudioUint ID parent object Not found.\n";
						return rError;
						
					case 0x0c:
						// output AID
						pthread_mutex_lock(&oMutex);
						for(dp=outputMap.begin(); dp!=outputMap.end(); dp++){
							if((*dp).second->OID == aLong){
								if(aum = (AUManager*)(*dp).second->getAUManager(bus)){
									slot = aum->insert(slot, sub, mfg);
									if(slot != 0xff){
										pthread_mutex_unlock(&oMutex);
										session->lastAID = aLong | ((uint32_t)slot << 24) | ((uint32_t)bus << 20);
										// send out notifications
										struct notifyData	data;
										data.senderID = getSenderID();
										data.reference = EndianS32_NtoB(aLong);
										data.value.iVal = EndianS32_NtoB((signed int)bus);
										Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
										return rOK;
									}else{
										session->errMSG = "Audio Unit insert failed.\n";
										pthread_mutex_unlock(&oMutex);
										return rError;
									}
								}
							}
						}
						pthread_mutex_unlock(&oMutex);
						session->errMSG = "AudioUint ID parent object Not found.\n";
						return rError;

					case 0x08:
						// player number AID				
						i = aLong & 0x000000ff;
						if(!checkPnumber(i)){
							session->errMSG = "Bad player number.\n";
							return rError;            
						}
						pLocks[i]->readLock(true);
						p = gLockedMem->pList[i];
						if(p != NULL){
							if(aum = (AUManager*)p->getAUManager(bus)){
								slot = aum->insert(slot, sub, mfg);
								if(slot != 0xff){
									pLocks[i]->readUnlock();
									session->lastAID = aLong | ((uint32_t)slot << 24);
									// send out notifications
									struct notifyData	data;
									data.senderID = getSenderID();
									data.reference = EndianS32_NtoB(aLong);
									data.value.iVal = EndianS32_NtoB((signed int)bus);
									Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
									return rOK;
								}else{
									session->errMSG = "Audio Unit insert failed.\n";
									pLocks[i]->readUnlock();
									return rError;
								}
							}
						}
						pLocks[i]->readUnlock();
						session->errMSG = "AudioUint ID parent object Not found.\n";
						return rError;
					
					default:
						session->errMSG = "Unknown AudioUint ID type\n";
						return rError;		
				}
			}
		}
	}
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

unsigned char handle_fxparam(ctl_session *session)
{
	char *param;
	char *end;
	char type;
	unsigned char slot, bus;
	char *parID;
	char *parVal;
	float val;
	Recorder *r;
	ARPlayer *p;
	AUManager *aum;
	uint32_t aLong;
	char buf[4096];
	string str;
	output_map_ptr dp;
	const char *cstr;
    int tx_length;
	uint32_t i;
	
	// first parameter, AID in hex format
	if(param = strtok_r(NULL, " ", &session->save_pointer)){
		if(strlen(param) > 2){
			// hex number (UID/AID/OID)
			aLong = strtoul(param, &end, 16);
		}else{
			if(atoi(param) == -1)		
				aLong = session->lastAID;									// -1: use lastAID
			else{
				session->errMSG = "Invalid AudioUnit ID.\n";
				return rError;
			}
		}	
		type = (aLong & 0xf0000000) >> 28;
		slot = (aLong & 0x0f000000) >> 24;
		bus = (aLong & 0x00f00000) >> 20;
		aLong = aLong & 0xf00fffff;
		// second (optional) parameter, parameter ID (decimal)
		if(parID = strtok_r(NULL, " ", &session->save_pointer)){
			// third (optional) parameter, parameter value (float)
			parVal = session->save_pointer;
		}else
			parVal = NULL;
		switch(type){
			case 0x00:
				// AID is a UID, player or recorder
				
				// first search recorder list
				rMutex->readLock(true);
				for(i=0; i<RecList.size(); i++){
					r = RecList.at(i);
					if(r->UID == aLong){
						if(r->locked == TRUE){
							// It's locked.  Fail!
							rMutex->readUnlock();
							session->errMSG = "Recorder is locked.\n";
							return rError;
						}
						if(aum = (AUManager*)r->getAUManager(bus)){
							if(parID == NULL){
								str = aum->dumpParam(slot);
								if(cstr = str.c_str()){
									tx_length = snprintf(buf, sizeof buf, "ParamID\tName\tValue\tmin\tmax\tdefault\tUnitID\tClump\tFlags\tUName\n");
									my_send(session->cs, buf, tx_length, session->silent);
									my_send(session->cs, cstr, strlen(cstr), session->silent);
									rMutex->readUnlock();
									return rNone;
								}
							}else if(parVal == NULL){
								val = aum->getParam(slot, atoi(parID));
								tx_length = snprintf(buf, sizeof buf, "%f\n", val);
								my_send(session->cs, buf, tx_length, session->silent);
								rMutex->readUnlock();
								return rNone;
							}else{
								aum->setParam(slot, atoi(parID), atof(parVal));
								rMutex->readUnlock();
								// send out notifications
								struct notifyData	data;
								data.senderID = getSenderID();
								data.reference = EndianS32_NtoB(aLong);
								data.value.iVal = EndianS32_NtoB((signed int)bus);
								Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
								return rOK;								
							}
						}
					}
				}
				rMutex->readUnlock();
				
				// next search player list
				for(i=0; i<gLockedMem->inBus; i++){
					pLocks[i]->readLock(true);
					p = gLockedMem->pList[i];
					if((p != NULL) && (p->UID == aLong)){
						if(aum = (AUManager*)p->getAUManager(bus)){
							if(parID == NULL){
								str = aum->dumpParam(slot);
								if(cstr = str.c_str()){
									tx_length = snprintf(buf, sizeof buf, "ParamID\tName\tValue\tmin\tmax\tdefault\tUnitID\tClump\tFlags\tUName\n");
									my_send(session->cs, buf, tx_length, session->silent);
									my_send(session->cs, cstr, strlen(cstr), session->silent);
									pLocks[i]->readUnlock();
									return rNone;
								}
							}else if(parVal == NULL){
								val = aum->getParam(slot, atoi(parID));
								tx_length = snprintf(buf, sizeof buf, "%f\n", val);
								my_send(session->cs, buf, tx_length, session->silent);
								pLocks[i]->readUnlock();
								return rNone;
							}else{
								aum->setParam(slot, atoi(parID), atof(parVal));
								pLocks[i]->readUnlock();
								// send out notifications
								struct notifyData	data;
								data.senderID = getSenderID();
								data.reference = EndianS32_NtoB(aLong);
								data.value.iVal = EndianS32_NtoB((signed int)bus);
								Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
								return rOK;								
							}
						}
					}
					pLocks[i]->readUnlock();
				}
				session->errMSG = "AudioUint ID parent object Not found.\n";
				return rError;
				
			case 0x0c:
				// output AID
				pthread_mutex_lock(&oMutex);
				for(dp=outputMap.begin(); dp!=outputMap.end(); dp++){
					if((*dp).second->OID == (aLong & 0xf00fffff)){
						if(aum = (AUManager*)(*dp).second->getAUManager(bus)){
							if(parID == NULL){
								str = aum->dumpParam(slot);
								if(cstr = str.c_str()){
									tx_length = snprintf(buf, sizeof buf, "ParamID\tName\tValue\tmin\tmax\tdefault\tUnitID\tClump\tFlags\tUName\n");
									my_send(session->cs, buf, tx_length, session->silent);
									my_send(session->cs, cstr, strlen(cstr), session->silent);
									pthread_mutex_unlock(&oMutex);
									return rNone;
								}
							}else if(parVal == NULL){
								val = aum->getParam(slot, atoi(parID));
								tx_length = snprintf(buf, sizeof buf, "%f\n", val);
								my_send(session->cs, buf, tx_length, session->silent);
								pthread_mutex_unlock(&oMutex);
								return rNone;
							}else{
								aum->setParam(slot, atoi(parID), atof(parVal));
								pthread_mutex_unlock(&oMutex);
								// send out notifications
								struct notifyData	data;
								data.senderID = getSenderID();
								data.reference = EndianS32_NtoB(aLong);
								data.value.iVal = EndianS32_NtoB((signed int)bus);
								Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
								return rOK;								
							}
						}
					}
				}
				pthread_mutex_unlock(&oMutex);
				session->errMSG = "AudioUint ID parent object Not found.\n";
				return rError;
						
			case 0x08:
				// player number AID				
				i = aLong & 0x000000ff;
				if(!checkPnumber(i)){
					session->errMSG = "Bad player number.\n";
					return rError;            
				}
				pLocks[i]->readLock(true);
				p = gLockedMem->pList[i];
				if(p != NULL){
					if(aum = (AUManager*)p->getAUManager(bus)){
						if(parID == NULL){
							str = aum->dumpParam(slot);
							if(cstr = str.c_str()){
								tx_length = snprintf(buf, sizeof buf, "ParamID\tName\tValue\tmin\tmax\tdefault\tUnitID\tClump\tFlags\tUName\n");
								my_send(session->cs, buf, tx_length, session->silent);
								my_send(session->cs, cstr, strlen(cstr), session->silent);
								pLocks[i]->readUnlock();
								return rNone;
							}
						}else if(parVal == NULL){
							val = aum->getParam(slot, atoi(parID));
							tx_length = snprintf(buf, sizeof buf, "%f\n", val);
							my_send(session->cs, buf, tx_length, session->silent);
							pLocks[i]->readUnlock();
							return rNone;
						}else{
							aum->setParam(slot, atoi(parID), atof(parVal));
							pLocks[i]->readUnlock();
							// send out notifications
							struct notifyData	data;
							data.senderID = getSenderID();
							data.reference = EndianS32_NtoB(aLong);
							data.value.iVal = EndianS32_NtoB((signed int)bus);
							Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
							return rOK;								
						}
					}
				}
				pLocks[i]->readUnlock();
				session->errMSG = "AudioUint ID parent object Not found.\n";
				return rError;
			
			default:
				session->errMSG = "Unknown AudioUint ID type\n";
				return rError;		
		}

	}
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

unsigned char handle_fxbypass(ctl_session *session)
{
	char *param;
	char *end;
	char type;
	unsigned char slot, bus;
	int value;
	Recorder *r;
	ARPlayer *p;
	output_map_ptr dp;
	AUManager *aum;
	uint32_t aLong;
	uint32_t i;
	
	// first parameter, AID in hex format
	if(param = strtok_r(NULL, " ", &session->save_pointer)){
		if(strlen(param) > 2){
			// hex number (UID/AID/OID)
			aLong = strtoul(param, &end, 16);
		}else{
			if(atoi(param) == -1)		
				aLong = session->lastAID;									// -1: use lastAID
			else{
				session->errMSG = "Invalid AudioUnit ID.\n";
				return rError;
			}
		}	
		type = (aLong & 0xf0000000) >> 28;
		slot = (aLong & 0x0f000000) >> 24;
		bus = (aLong & 0x00f00000) >> 20;
		aLong = aLong & 0xf00fffff;
		// second  parameter, bypass state (0 or 1)
		if(session->save_pointer){
			value = atoi(session->save_pointer);
			switch(type){
				case 0x00:
					// AID is a UID, player or recorder
					
					// first search recorder list
					rMutex->readLock(true);
					for(i=0; i<RecList.size(); i++){
						r = RecList.at(i);
						if(r->UID == aLong){
							if(r->locked == TRUE){
								// It's locked.  Fail!
								rMutex->readUnlock();
								session->errMSG = "Recorder is locked.\n";
								return rError;
							}
							if(aum = (AUManager*)r->getAUManager(bus)){
								aum->bypass(slot, value);
								rMutex->readUnlock();
								// send out notifications
								struct notifyData	data;
								data.senderID = getSenderID();
								data.reference = EndianS32_NtoB(aLong);
								data.value.iVal = EndianS32_NtoB((signed int)bus);
								Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
								return rOK;								
							}
						}
					}
					rMutex->readUnlock();
					
					// next search player list
					for(i=0; i<gLockedMem->inBus; i++){
						pLocks[i]->readLock(true);
						p = gLockedMem->pList[i];
						if((p != NULL) && (p->UID == aLong)){
							if(aum = (AUManager*)p->getAUManager(bus)){
								aum->bypass(slot, value);
								pLocks[i]->readUnlock();
								// send out notifications
								struct notifyData	data;
								data.senderID = getSenderID();
								data.reference = EndianS32_NtoB(aLong);
								data.value.iVal = EndianS32_NtoB((signed int)bus);
								Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
								return rOK;								
							}
						}
						pLocks[i]->readUnlock();
					}
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;
					
				case 0x0c:
					// output AID
					pthread_mutex_lock(&oMutex);
					for(dp=outputMap.begin(); dp!=outputMap.end(); dp++){
						if((*dp).second->OID == (aLong & 0xf00fffff)){
							if(aum = (AUManager*)(*dp).second->getAUManager(bus)){
								aum->bypass(slot, value);
								pthread_mutex_unlock(&oMutex);
								// send out notifications
								struct notifyData	data;
								data.senderID = getSenderID();
								data.reference = EndianS32_NtoB(aLong);
								data.value.iVal = EndianS32_NtoB((signed int)bus);
								Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
								return rOK;								
							}
						}
					}
					pthread_mutex_unlock(&oMutex);
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;

				case 0x08:
					// player number AID				
					i = aLong & 0x000000ff;
					if(!checkPnumber(i)){
						session->errMSG = "Bad player number.\n";
						return rError;            
					}
					pLocks[i]->readLock(true);
					p = gLockedMem->pList[i];
					if(p != NULL){
						if(aum = (AUManager*)p->getAUManager(bus)){
							aum->bypass(slot, value);
							pLocks[i]->readUnlock();
							// send out notifications
							struct notifyData	data;
							data.senderID = getSenderID();
							data.reference = EndianS32_NtoB(aLong);
							data.value.iVal = EndianS32_NtoB((signed int)bus);
							Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
							return rOK;								
						}
					}
					pLocks[i]->readUnlock();
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;
				
				default:
					session->errMSG = "Unknown AudioUint ID type\n";
					return rError;		
			}
		}
	}
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

unsigned char handle_fxvalstr(ctl_session *session)
{
	char *param;
	char *end;
	char type;
	unsigned char slot, bus;
	char *parID;
	Recorder *r;
	ARPlayer *p;
	AUManager *aum;
	uint32_t aLong;
	string str;
	output_map_ptr dp;
	const char *cstr;
	uint32_t i;
	
	// first parameter, AID in hex format
	if(param = strtok_r(NULL, " ", &session->save_pointer)){
		if(strlen(param) > 2){
			// hex number (UID/AID/OID)
			aLong = strtoul(param, &end, 16);
		}else{
			if(atoi(param) == -1)		
				aLong = session->lastAID;									// -1: use lastAID
			else{
				session->errMSG = "Invalid AudioUnit ID.\n";
				return rError;
			}
		}	
		type = (aLong & 0xf0000000) >> 28;
		slot = (aLong & 0x0f000000) >> 24;
		bus = (aLong & 0x00f00000) >> 20;
		aLong = aLong & 0xf00fffff;
		// second parameter, parameter ID (decimal)
		if(parID = session->save_pointer){
			switch(type){
				case 0x00:
					// AID is a UID, player or recorder
					
					// first search recorder list
					rMutex->readLock(true);
					for(i=0; i<RecList.size(); i++){
						r = RecList.at(i);
						if(r->UID == aLong){
							if(r->locked == TRUE){
								// It's locked.  Fail!
								rMutex->readUnlock();
								session->errMSG = "Recorder is locked.\n";
								return rError;
							}
							if(aum = (AUManager*)r->getAUManager(bus)){
								str = aum->getParamStrings(slot, atoi(parID));
								if(cstr = str.c_str()){
									my_send(session->cs, cstr, strlen(cstr), session->silent);
									rMutex->readUnlock();
									return rNone;
								}
							}
						}
					}
					rMutex->readUnlock();
					
					// next search player list
					for(i=0; i<gLockedMem->inBus; i++){
						pLocks[i]->readLock(true);
						p = gLockedMem->pList[i];
						if((p != NULL) && (p->UID == aLong)){
							if(aum = (AUManager*)p->getAUManager(bus)){
								str = aum->getParamStrings(slot, atoi(parID));
								if(cstr = str.c_str()){
									my_send(session->cs, cstr, strlen(cstr), session->silent);
									pLocks[i]->readUnlock();
									return rNone;
								}
							}
						}
						pLocks[i]->readUnlock();
					}
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;
					
				case 0x0c:
					// output AID
					pthread_mutex_lock(&oMutex);
					for(dp=outputMap.begin(); dp!=outputMap.end(); dp++){
						if((*dp).second->OID == (aLong & 0xf00fffff)){
							if(aum = (AUManager*)(*dp).second->getAUManager(bus)){
								str = aum->getParamStrings(slot, atoi(parID));
								if(cstr = str.c_str()){
									my_send(session->cs, cstr, strlen(cstr), session->silent);
									pthread_mutex_unlock(&oMutex);
									return rNone;
								}
							}
						}
					}
					pthread_mutex_unlock(&oMutex);
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;
							
				case 0x08:
					// player number AID				
					i = aLong & 0x000000ff;
					if(!checkPnumber(i)){
						session->errMSG = "Bad player number.\n";
						return rError;            
					}
					pLocks[i]->readLock(true);
					p = gLockedMem->pList[i];
					if(p != NULL){
						if(aum = (AUManager*)p->getAUManager(bus)){
							str = aum->getParamStrings(slot, atoi(parID));
							if(cstr = str.c_str()){
								my_send(session->cs, cstr, strlen(cstr), session->silent);
								pLocks[i]->readUnlock();
								return rNone;
							}
						}
					}
					pLocks[i]->readUnlock();
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;
				
				default:
					session->errMSG = "Unknown AudioUint ID type\n";
					return rError;		
			}
		}
	}
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

unsigned char handle_fxsave(ctl_session *session)
{
	char *param;
	char *end;
	unsigned char type, bindex;
	Recorder *r;
	ARPlayer *p;
	AUManager *aum[16];		// never more than 16 busses
	uint32_t aLong;
	string str;
	output_map_ptr dp;
	uint32_t i;
	
	// first parameter, UID in hex format
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		if(strlen(param) > 2){
			// hex number (UID/AID/OID)
			aLong = strtoul(param, &end, 16);
		}else{
			if(atoi(param) < 0)		
				aLong = session->lastUID;									// -1: use lastUID
			else					
				aLong = (uint32_t)atoi(param) | 0x80000000;	// player number
		}	
		type = (aLong & 0xf0000000) >> 28;
		aLong = aLong & 0xf00fffff;
		// second parameter, save name, kept in save_pointer
		if(session->save_pointer){
			switch(type){
				case 0x00:
					// AID is a UID, player or recorder
					
					// first search recorder list
					rMutex->readLock(true);
					for(i=0; i<RecList.size(); i++){
						r = RecList.at(i);
						if(r->UID == aLong){
							if(r->locked == TRUE){
								// It's locked.  Fail!
								rMutex->readUnlock();
								session->errMSG = "Recorder is locked.\n";
								return rError;
							}
							bindex = 0;
							while((bindex < 16) && (aum[bindex] = (AUManager*)r->getAUManager(bindex)))
								bindex++;
							if(bindex){	
								if(saveFXConfigFile(aum, bindex, session->save_pointer)){
									rMutex->readUnlock();
									return rOK;
								}else{
									rMutex->readUnlock();
									session->errMSG = "Failed to save effects configuration.\n";
									return rError;
								}
							}
						}
					}
					rMutex->readUnlock();
					
					// next search player list
					for(i=0; i<gLockedMem->inBus; i++){
						pLocks[i]->readLock(true);
						p = gLockedMem->pList[i];
						if((p != NULL) && (p->UID == aLong)){
							bindex = 0;
							while((bindex < 16) && (aum[bindex] = (AUManager*)p->getAUManager(bindex)))
								bindex++;
							if(bindex){	
								if(saveFXConfigFile(aum, bindex, session->save_pointer)){
									pLocks[i]->readUnlock();
									return rOK;
								}else{
									pLocks[i]->readUnlock();
									session->errMSG = "Failed to save effects configuration.\n";
									return rError;
								}
							}
						}
						pLocks[i]->readUnlock();
					}
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;
					
				case 0x0c:
					// output AID
					pthread_mutex_lock(&oMutex);
					for(dp=outputMap.begin(); dp!=outputMap.end(); dp++){
						if((*dp).second->OID == (aLong & 0xf00fffff)){
							bindex = 0;
							while((bindex < 16) && (aum[bindex] = (AUManager*)(*dp).second->getAUManager(bindex)))
								bindex++;
							if(bindex){	
								if(saveFXConfigFile(aum, bindex, session->save_pointer)){
									pthread_mutex_unlock(&oMutex);
									return rOK;
								}else{
									pthread_mutex_unlock(&oMutex);
									session->errMSG = "Failed to save effects configuration.\n";
									return rError;
								}
							}
						}
					}
					pthread_mutex_unlock(&oMutex);
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;
											
				case 0x08:
					// player number AID				
					i = aLong & 0x000000ff;
					if(!checkPnumber(i)){
						session->errMSG = "Bad player number.\n";
						return rError;            
					}
					pLocks[i]->readLock(true);
					p = gLockedMem->pList[i];
					if(p != NULL){
						bindex = 0;
						while((bindex < 16) && (aum[bindex] = (AUManager*)p->getAUManager(bindex)))
							bindex++;
						if(bindex){	
							if(saveFXConfigFile(aum, bindex, session->save_pointer)){
								pLocks[i]->readUnlock();
								return rOK;
							}else{
								pLocks[i]->readUnlock();
								session->errMSG = "Failed to save effects configuration.\n";
								return rError;
							}
						}
					}
					pLocks[i]->readUnlock();
					session->errMSG = "AudioUint ID parent object Not found.\n";
					return rError;
				
				default:
					session->errMSG = "Unknown AudioUint ID parent type\n";
					return rError;		
			}
		}
	}
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

unsigned char handle_fxpreset(ctl_session *session)
{

	char *param;
	char *end;
	char type;
	unsigned char slot, bus;
	char *parID;
	Recorder *r;
	ARPlayer *p;
	AUManager *aum;
	uint32_t aLong;
	char buf[4096];
	string str;
	output_map_ptr dp;
	const char *cstr;
    int tx_length;
	uint32_t i;
	
	// first parameter, AID in hex format
	if(param = strtok_r(NULL, " ", &session->save_pointer)){
		if(strlen(param) > 2){
			// hex number (UID/AID/OID)
			aLong = strtoul(param, &end, 16);
		}else{
			if(atoi(param) == -1)		
				aLong = session->lastAID;									// -1: use lastAID
			else{
				session->errMSG = "Invalid AudioUnit ID.\n";
				return rError;
			}
		}	
		type = (aLong & 0xf0000000) >> 28;
		slot = (aLong & 0x0f000000) >> 24;
		bus = (aLong & 0x00f00000) >> 20;
		aLong = aLong & 0xf00fffff;
		// second (optional) parameter, parameter ID (decimal)
		parID = session->save_pointer;
		switch(type){
			case 0x00:
				// AID is a UID, player or recorder
				
				// first search recorder list
				rMutex->readLock(true);
				for(i=0; i<RecList.size(); i++){
					r = RecList.at(i);
					if(r->UID == aLong){
						if(r->locked == TRUE){
							// It's locked.  Fail!
							rMutex->readUnlock();
							session->errMSG = "Recorder is locked.\n";
							return rError;
						}
						if(aum = (AUManager*)r->getAUManager(bus)){
							if(parID == NULL){
								str = aum->presets(slot);
								if(cstr = str.c_str()){
									tx_length = snprintf(buf, sizeof buf, "PresetID\tName\n");
									my_send(session->cs, buf, tx_length, session->silent);
									my_send(session->cs, cstr, strlen(cstr), session->silent);
									rMutex->readUnlock();
									return rNone;
								}
							}else{
								aum->load(slot, atoi(parID));
								rMutex->readUnlock();
								// send out notifications
								struct notifyData	data;
								data.senderID = getSenderID();
								data.reference = EndianS32_NtoB(aLong);
								data.value.iVal = EndianS32_NtoB((signed int)bus);
								Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
								return rOK;								
							}
						}
					}
				}
				rMutex->readUnlock();
				
				// next search player list
				for(i=0; i<gLockedMem->inBus; i++){
					pLocks[i]->readLock(true);
					p = gLockedMem->pList[i];
					if((p != NULL) && (p->UID == aLong)){
						if(aum = (AUManager*)p->getAUManager(bus)){
							if(parID == NULL){
								str = aum->presets(slot);
								if(cstr = str.c_str()){
									tx_length = snprintf(buf, sizeof buf, "PresetID\tName\n");
									my_send(session->cs, buf, tx_length, session->silent);
									my_send(session->cs, cstr, strlen(cstr), session->silent);
									pLocks[i]->readUnlock();
									return rNone;
								}
							}else{
								aum->load(slot, atoi(parID));
								pLocks[i]->readUnlock();
								// send out notifications
								struct notifyData	data;
								data.senderID = getSenderID();
								data.reference = EndianS32_NtoB(aLong);
								data.value.iVal = EndianS32_NtoB((signed int)bus);
								Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
								return rOK;								
							}
						}
					}
					pLocks[i]->readUnlock();
				}
				session->errMSG = "AudioUint ID parent object Not found.\n";
				return rError;
				
			case 0x0c:
				// output AID
				pthread_mutex_lock(&oMutex);
				for(dp=outputMap.begin(); dp!=outputMap.end(); dp++){
					if((*dp).second->OID == (aLong & 0xf00fffff)){
						if(aum = (AUManager*)(*dp).second->getAUManager(bus)){
							if(parID == NULL){
								str = aum->presets(slot);
								if(cstr = str.c_str()){
									tx_length = snprintf(buf, sizeof buf, "PresetID\tName\n");
									my_send(session->cs, buf, tx_length, session->silent);
									my_send(session->cs, cstr, strlen(cstr), session->silent);
									pthread_mutex_unlock(&oMutex);
									return rNone;
								}
							}else{
								aum->load(slot, atoi(parID));
								pthread_mutex_unlock(&oMutex);
								// send out notifications
								struct notifyData	data;
								data.senderID = getSenderID();
								data.reference = EndianS32_NtoB(aLong);
								data.value.iVal = EndianS32_NtoB((signed int)bus);
								Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
								return rOK;								
							}
						}
					}
				}
				pthread_mutex_unlock(&oMutex);
				session->errMSG = "AudioUint ID parent object Not found.\n";
				return rError;
						
			case 0x08:
				// player number AID				
				i = aLong & 0x000000ff;
				if(!checkPnumber(i)){
					session->errMSG = "Bad player number.\n";
					return rError;            
				}
				pLocks[i]->readLock(true);
				p = gLockedMem->pList[i];
				if(p != NULL){
					if(aum = (AUManager*)p->getAUManager(bus)){
						if(parID == NULL){
							str = aum->presets(slot);
							if(cstr = str.c_str()){
								tx_length = snprintf(buf, sizeof buf, "PresetID\tName\n");
								my_send(session->cs, buf, tx_length, session->silent);
								my_send(session->cs, cstr, strlen(cstr), session->silent);
								pLocks[i]->readUnlock();
								return rNone;
							}
						}else{
							aum->load(slot, atoi(parID));
							pLocks[i]->readUnlock();
							// send out notifications
							struct notifyData	data;
							data.senderID = getSenderID();
							data.reference = EndianS32_NtoB(aLong);
							data.value.iVal = EndianS32_NtoB((signed int)bus);
							Notifier->MakeEntry(nType_fxchain, &data, sizeof(data), -1);
							return rOK;								
						}
					}
				}
				pLocks[i]->readUnlock();
				session->errMSG = "AudioUint ID parent object Not found.\n";
				return rError;
			
			default:
				session->errMSG = "Unknown AudioUint ID type\n";
				return rError;		
		}

	}
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

unsigned char handle_fxwatch(ctl_session *session)
{

	char *end;
	char type;
	unsigned char slot, bus;
	Recorder *r;
	ARPlayer *p;
	AUManager *aum;
	uint32_t aLong, locID;
	string str;
	output_map_ptr dp;
	uint32_t i;
	
	// first parameter, AID in hex format
	if(session->save_pointer == NULL){
		// no parameter... stop fx parameter listening
		setSessionFXWatch(session->cs, NULL, 0, 0);
		return rOK;								
	}else{
		if(strlen(session->save_pointer) > 2){
			// hex number (UID/AID/OID)
			aLong = strtoul(session->save_pointer, &end, 16);
		}else{
			if(atoi(session->save_pointer) == -1)		
				aLong = session->lastAID;									// -1: use lastAID
			else{
				session->errMSG = "Invalid AudioUnit ID.\n";
				return rError;
			}
		}	
		type = (aLong & 0xf0000000) >> 28;
		slot = (aLong & 0x0f000000) >> 24;
		bus = (aLong & 0x00f00000) >> 20;
		locID = aLong & 0xf00fffff;
		switch(type){
			case 0x00:
				// AID is a UID, player or recorder
				
				// first search recorder list
				rMutex->readLock(true);
				for(i=0; i<RecList.size(); i++){
					r = RecList.at(i);
					if(r->UID == locID){
						if(r->locked == TRUE){
							// It's locked.  Fail!
							rMutex->readUnlock();
							session->errMSG = "Recorder is locked.\n";
							return rError;
						}
						if(aum = (AUManager*)r->getAUManager(bus)){
							setSessionFXWatch(session->cs, aum, slot, aLong);
							rMutex->readUnlock();
							return rOK;								
						}
					}
				}
				rMutex->readUnlock();
				
				// next search player list
				for(i=0; i<gLockedMem->inBus; i++){
					pLocks[i]->readLock(true);
					p = gLockedMem->pList[i];
					if((p != NULL) && (p->UID == locID)){
						if(aum = (AUManager*)p->getAUManager(bus)){
							setSessionFXWatch(session->cs, aum, slot, aLong);
							pLocks[i]->readUnlock();
							return rOK;								
						}
					}
					pLocks[i]->readUnlock();
				}
				session->errMSG = "AudioUint ID parent object Not found.\n";
				return rError;
				
			case 0x0c:
				// output AID
				pthread_mutex_lock(&oMutex);
				for(dp=outputMap.begin(); dp!=outputMap.end(); dp++){
					if((*dp).second->OID == (locID & 0xf00fffff)){
						if(aum = (AUManager*)(*dp).second->getAUManager(bus)){
							setSessionFXWatch(session->cs, aum, slot, aLong);
							pthread_mutex_unlock(&oMutex);
							return rOK;								
						}
					}
				}
				pthread_mutex_unlock(&oMutex);
				session->errMSG = "AudioUint ID parent object Not found.\n";
				return rError;
						
			case 0x08:
				// player number AID				
				i = locID & 0x000000ff;
				if(!checkPnumber(i)){
					session->errMSG = "Bad player number.\n";
					return rError;            
				}
				pLocks[i]->readLock(true);
				p = gLockedMem->pList[i];
				if(p != NULL){
					if(aum = (AUManager*)p->getAUManager(bus)){
						setSessionFXWatch(session->cs, aum, slot, aLong);
						pLocks[i]->readUnlock();
						return rOK;								
					}
				}
				pLocks[i]->readUnlock();
				session->errMSG = "AudioUint ID parent object Not found.\n";
				return rError;
			
			default:
				session->errMSG = "Unknown AudioUint ID type\n";
				return rError;		
		}

	}
	session->errMSG = "Missing or bad parameter.\n";
	return rError;
}

void setSessionFXWatch(int cs, AUManager *aum, unsigned char slot, uint32_t AID)
{	
	// first unregister any existing watches on this session
	fxWatchObject->canceSocketEntry(cs);
	
	// next, register new AID to watch
	if(aum)
		aum->setListen(slot, cs, AID);
}

unsigned char saveFXConfigFile(AUManager *aum[], unsigned char count, char *fileName)
{
	FILE *fp;
	unsigned char i, bus, slot, bypass;
	uint32_t n, pid;
	float pval;
	string sstr, pstr, line, val, mfg, sub, fPath;
	
	// save all the effects slots and parameters attached to the device
	if(fileName){	
		if(strlen(fileName) > 0){
			fPath = GetMetaData(0, "file_fx_dir");
			if(fPath.length() > 0){
				if(fPath[fPath.length()-1] != '/'){
					// add trailing slash
					fPath = fPath + directoryTolkenStr + string(fileName);
				}else{	
					fPath = fPath + string(fileName);
				}
			}else
				fPath = string(fileName);
		
			if((fp=fopen(fPath.c_str(), "w")) != NULL){
				fprintf(fp, "; Effects settings for all buses and slots of device\n");
				for(bus=0; bus<count; bus++){
					// list of slots
					sstr = aum[bus]->list();
					i=0;
					line = NthField(sstr, "\n", i);
					while(line.length()){
						val = NthField(line, "\t", 0);
						slot = atoi(val.c_str());
						val = NthField(line, "\t", 2);
						bypass = atoi(val.c_str());
						sub = NthField(line, "\t", 3);
						mfg = NthField(line, "\t", 4);
						
						fprintf(fp, "fxinsert -1 %d %d %s %s\n", slot, bus, sub.c_str(), mfg.c_str());
						if(sub.length() && mfg.length()){
							// unit specified... save the units parameters too...
							fprintf(fp, "fxbypass -1 %d\n", bypass);
							pstr = aum[bus]->dumpParam(slot);
							n=0;
							line = NthField(pstr, "\n", n);
							while(line.length()){
								val = NthField(line, "\t", 0);
								pid = atoi(val.c_str());
								val = NthField(line, "\t", 2);
								pval = atof(val.c_str());
								fprintf(fp, "fxparam -1 %u %f\n", (unsigned int)pid, pval);
								n++;
								line = NthField(pstr, "\n", n);
							}
						}
						i++;
						line = NthField(sstr, "\n", i);
					}
				}
				fclose(fp);
				return true;
			}
		}
	}
	return false;
}

unsigned char lsFXConfigDir(ctl_session *session)
{
	struct dirent **entList;
	int count;
	int i;
	char buf[4096]; /* send data buffer */
	const char *cstr;
    int tx_length;
	string dir;

	dir = GetMetaData(0, "file_fx_dir");
	if(dir.length() > 0){
		if(dir[dir.length()-1] != '/'){
			// add trailing slash
			dir = dir + "/";
		}
	}else
		dir = "";
	cstr = dir.c_str();
	my_send(session->cs, cstr, strlen(cstr), session->silent);
	my_send(session->cs, "\n", 1, session->silent);
	if((count = scandir(dir.c_str(), &entList, fxdirSelect, alphasort)) > 0){
		for(i = 0; i < count; i++){
			tx_length = snprintf(buf, sizeof buf, "%s\n", entList[i]->d_name);
			my_send(session->cs, buf, tx_length, session->silent);
		}
		free(entList);
	}
	return rOK;								
}

int fxdirSelect(struct dirent *ent)
{
	char *frag, *last;
	
	// eliminate all entries that are not regular files
	if(ent->d_type == DT_REG){
		// and that do not end in ".fx"
		last = ent->d_name;
		while(frag = strstr(last, ".fx"))
			last = frag + 3;
		if(last == (ent->d_name + (ent->d_namlen)))
			return true;
	}
	return false;
}

void fxLoadConfigFromTask(TaskItem *parent)
{
//  How to call this function:
//	TaskItem *task;
//	task = new TaskItem(fileName, fxLoadConfigFromTask, NULL, uid, 0L, false); // no timeout

	ctl_session session;
	string path;
	
	if(parent->name.length() > 0){
		path = GetMetaData(0, "file_fx_dir");
		if(path.length() > 0){
			if(path[path.length()-1] != '/'){
				// add trailing slash
				path = path + "/" + parent->name;
			}else{	
				path = path + parent->name;
			}
			session.cs = 0;
			session.silent = true;
			session.lastAID = 0;
			session.lastUID = parent->UID;
			loadConfiguration(&session, path);
		}
	}
}

void loadConfigFromTask(TaskItem *parent)
{
	//  How to call this function:
	//	TaskItem *task;
	//	task = new TaskItem(filePath, loadConfigFromTask, NULL, uid, 0L, false); // no timeout
	
	ctl_session session;
	string path;

	session.cs = 0;
	session.silent = true;
	session.lastAID = 0;
	session.lastUID = parent->UID;
	
	if(parent->name.length() > 0){

		loadConfiguration(&session, parent->name);
	}
}


unsigned char handle_getcodecs(ctl_session *session)
{
    uint32_t theSize, *List;
	char buf[8]; /* send data buffer */
    int tx_length, num, i;
    OSStatus OSerr;
    
	tx_length = snprintf(buf, sizeof buf, "encode\n");
	my_send(session->cs, buf, tx_length, session->silent);

	OSerr = AudioFormatGetPropertyInfo(kAudioFormatProperty_EncodeFormatIDs, 0, NULL, &theSize);
	if(OSerr){
		session->errMSG = "CoreAudio Unit error.\n";
		return rError;
	}
	List = (uint32_t*)malloc(theSize);
	num = theSize / sizeof(uint32_t);
	OSerr = AudioFormatGetProperty(kAudioFormatProperty_EncodeFormatIDs, 0, NULL, &theSize, List);
	if(OSerr){
		free(List);
		session->errMSG = "CoreAudio Unit error.\n";
		return rError;
	}
	
    for(i=0; i<num; i++){    // loop through the list  
		
		tx_length = snprintf(buf, sizeof buf, "%c%c%c%c\n", (List[i]&0xFF000000)>>24, (List[i]&0x00FF0000)>>16, (List[i]&0x0000FF00)>>8, List[i]&0x000000FF);
		my_send(session->cs, buf, tx_length, session->silent);
    }
	free(List);
	
	tx_length = snprintf(buf, sizeof buf, "decode\n");
	my_send(session->cs, buf, tx_length, session->silent);

	OSerr = AudioFormatGetPropertyInfo(kAudioFormatProperty_DecodeFormatIDs, 0, NULL, &theSize);
	if(OSerr){
		session->errMSG = "CoreAudio Unit error.\n";
		return rError;
	}
	List = (uint32_t*)malloc(theSize);
	num = theSize / sizeof(uint32_t);
	OSerr = AudioFormatGetProperty(kAudioFormatProperty_DecodeFormatIDs, 0, NULL, &theSize, List);
	if(OSerr){
		free(List);
		session->errMSG = "CoreAudio Unit error.\n";
		return rError;
	}
	
    for(i=0; i<num; i++){    // loop through the list  
		
		tx_length = snprintf(buf, sizeof buf, "%c%c%c%c\n", (List[i]&0xFF000000)>>24, (List[i]&0x00FF0000)>>16, (List[i]&0x0000FF00)>>8, List[i]&0x000000FF);
		my_send(session->cs, buf, tx_length, session->silent);
    }
	free(List);
	
	return rNone;
}

void ShutDown(void)
{
    uint32_t i;
    ARPlayer *playerPtr = nil;
    
    // stop and unload all player
    for (i=0; i<gLockedMem->inBus; ++i) {
		pLocks[i]->writeLock(true, "ShutDown");
        playerPtr = gLockedMem->pList[i];
        if(playerPtr != nil){
            playerPtr->stop();
            delete playerPtr;
        }
		pLocks[i]->writeUnlock();  
    } 
	
    // shut down audio engine
    CloseAudioSystem();
}

OSStatus MixFromSources(void *inRefCon, AudioUnitRenderActionFlags *inActionFlags, const AudioTimeStamp *inTimeStamp, uint32_t inBusNumber, uint32_t inNumberFrames, AudioBufferList *ioData)
{
	sourceRec *sourceRecPtr;
    uint32_t s, i, sChan, dGrp, buses, bsizebytes;
	int dChan;
	unsigned char more;
    ARPlayer *playerPtr;
	float *sourcePtr, *destPtr;
	float SampSqrd, pk, avr;
	uint32_t localBusUse;
    OSStatus err;
	
    // this is called by the master output to render the next block of audio frames
	// clear mix buffers
	for(i = 0 ; i < ioData->mNumberBuffers ; i++){
		bzero(ioData->mBuffers[i].mData, ioData->mBuffers[i].mDataByteSize);
	}
	localBusUse = 0L;
	for(s = 0 ; s < gLockedMem->inBus ; s++){
		// cycle through the sources, adding the returned bufferd from each to the mix bus buffers		
		sourceRecPtr = &gLockedMem->sourceList[s];
		playerPtr = sourceRecPtr->connectedPtr;
		if(playerPtr == NULL){
			// source is NOT connected
			if(sourceRecPtr->requestPtr){
				// connection requested
				sourceRecPtr->connectedPtr = sourceRecPtr->requestPtr;
				sourceRecPtr->requestPtr = NULL;
				sourceRecPtr->connectedPtr->connected = true;
			}
		}else{
			if(playerPtr->disconnect){
				// we are done, if a disconnect is requested, now is the time to do it.
				sourceRecPtr->connectedPtr = NULL;
				sourceRecPtr->requestPtr = NULL;
				playerPtr->connected = false;
			}else{
				if(((playerPtr->status & status_playing) != 0) || ((playerPtr->status & status_cueing) != 0))
					localBusUse = localBusUse | playerPtr->bus_assignment;
				// source is connected... get audio data
				more = 0;
				do{
					buses = 0;
					*inActionFlags = 0;
					
					// note the buffer byte size, so we can restore it after rendering
					bsizebytes = gLockedMem->sourceBuffers->mBuffers[0].mDataByteSize;

					err = playerPtr->renderIntoMixer(playerPtr, &buses, inActionFlags, inTimeStamp, inNumberFrames, gLockedMem->sourceBuffers, &more);			
					if((err == noErr) && ((*inActionFlags & kAudioUnitRenderAction_OutputIsSilence) == 0)){
						if((playerPtr->status & status_talkback) != 0)
							localBusUse = localBusUse | 2L;
						if(gLockedMem->passthru){
							// override the bus assignments and pass the source through to it's corrisponding bus number mod 4
							buses = (1L << (s % 4));
						}
						// cycle through the output channels... add source data where required
						for(dGrp = 0; dGrp < gLockedMem->outBus; dGrp++){
							if((1L << dGrp) & buses){
								dChan = dGrp * chanWidth;
								for(sChan = 0; sChan < chanWidth; sChan++){
									// this bus is selected... add sample to mixbuffer
									sourcePtr = (float*)(gLockedMem->sourceBuffers->mBuffers[sChan].mData);
									destPtr = (float*)(ioData->mBuffers[dChan+sChan].mData);
									for (i = 0; i < inNumberFrames; i++){
										// sample by sample adder
										destPtr[i] = destPtr[i] + sourcePtr[i];
									}
								}
							}	
						}
					}
					// restore buffer byte size
					for(sChan = 0; sChan < gLockedMem->sourceBuffers->mNumberBuffers; sChan++)
						gLockedMem->sourceBuffers->mBuffers[sChan].mDataByteSize = bsizebytes;					
				}while(more);
			}
		}
	}
	// handle cueInsert, if enabled
	if(gLockedMem->cueInsertPtr){
		double localInTime;
		if(localInTime = gLockedMem->cueInsertTime){
			if(gLockedMem->cueChanCount){
				int cmap[chanWidth];
				void *temp;
				int buffCount, adjust;
				SInt64 locSampleTime;
				double actual, error, locLatency;

				// set latency high: recorder and IAX feed threads are NOT high priority like all the audio threads
				// so we need high latency incase a recorder is the source for effects cueing.
				locLatency = gLockedMem->cueTargetLatency * 10;
				if(gLockedMem->cueIOOffset == 0){
					gLockedMem->cueIOOffset = gLockedMem->cueOutputTime + inNumberFrames + locLatency - localInTime;
					gLockedMem->cueErrorFactor = 0;
				} 				
				// device sync control algorithm	
				actual = localInTime - (gLockedMem->cueOutputTime + inNumberFrames - gLockedMem->cueIOOffset);
				error = actual - locLatency;
				if(-error > locLatency){
					// ahead by more than a buffer, skip back error samples and drop this frame (drop audio)
					gLockedMem->cueIOOffset = gLockedMem->cueIOOffset - error;
				}else{
					if(error > locLatency){
						// behind by more than a buffer, skip ahead error samples (audio skip)
						gLockedMem->cueIOOffset = gLockedMem->cueIOOffset - error;
						gLockedMem->cueErrorFactor = 0.0;
					}else{
						// avarage the error... to avarage out the buffer size quantization
						gLockedMem->cueErrorFactor = gLockedMem->cueErrorFactor + (error * gLockedMem->cueAvrFactor);
						// quantize error to integer sample change of 0, +1 or -1
						adjust = (int)gLockedMem->cueErrorFactor;
						if(adjust > 1) adjust = 1;
						if(adjust < -1) adjust = -1;
						gLockedMem->cueIOOffset = gLockedMem->cueIOOffset - adjust;
						gLockedMem->cueErrorFactor = gLockedMem->cueErrorFactor - adjust;	
					}
					// Flag cue bus use
					localBusUse = localBusUse | (1L << 1);
					// save original buffer count, and set to chanWidth
					buffCount = ioData->mNumberBuffers;
					ioData->mNumberBuffers = chanWidth;
					// swap first bus group of buffers with the second (cue) bus and set up channel mapping
					for(i=0; i<chanWidth; i++){
						if(i < gLockedMem->cueChanCount)
							cmap[i] = i;
						else
							cmap[i] = gLockedMem->cueChanCount - 1;
						temp = ioData->mBuffers[i].mData;
						ioData->mBuffers[i].mData = ioData->mBuffers[chanWidth+i].mData;
						ioData->mBuffers[chanWidth+i].mData = temp;
					}
					// add the cue insert data to the cue bus ioData buffers
					locSampleTime = (SInt64)(gLockedMem->cueOutputTime - gLockedMem->cueIOOffset);
					if(gLockedMem->cueInsertBuffer->FetchAdd(ioData, (uint32_t)inNumberFrames, locSampleTime, 0, cmap) == kAudioRingBufferError_OK){
						gLockedMem->cueOutputTime = gLockedMem->cueOutputTime + inNumberFrames;
					}
					// swap buffers back they way they were
					for(i=0; i<chanWidth; i++){
						temp = ioData->mBuffers[i].mData;
						ioData->mBuffers[i].mData = ioData->mBuffers[chanWidth+i].mData;
						ioData->mBuffers[chanWidth+i].mData = temp;
					}
					// restore original buffer count
					ioData->mNumberBuffers = buffCount;
				}
			}
		}
	}
	
	// Generate new output meters readings
	for (dChan = 0; dChan < gLockedMem->outBus * chanWidth; dChan++){
		pk = 0.0;
		avr = 0.0;
		destPtr = (float*)(ioData->mBuffers[dChan].mData);
		for (i = 0; i < inNumberFrames; i++){
				SampSqrd = destPtr[i] * destPtr[i];
				avr = avr + SampSqrd;
				if(SampSqrd > pk)
					pk = SampSqrd;
		}
		// avarage over 10,000 samples - aprox 10 Hz @ sample rate = 96,000
		gLockedMem->avrOutputMeter[dChan] = ( 1 - (0.0001 * inNumberFrames)) * gLockedMem->avrOutputMeter[dChan] + 0.0001 * avr;
		// fall time constatnt is 50,000 samples - aprox 2 Hz @ sample rate = 96,000
		gLockedMem->pkOutputMeter[dChan] = gLockedMem->pkOutputMeter[dChan] * ( 1 - (0.00002 * inNumberFrames));
		if(pk > gLockedMem->pkOutputMeter[dChan])
			gLockedMem->pkOutputMeter[dChan] = pk;
		
	}
	if(gLockedMem->busUse != localBusUse){
		gLockedMem->busUse = localBusUse;
		pthread_cond_broadcast(&gLockedMem->muteSemaphore);
	}
    return noErr; 
} 

void InitAudioSystem(void)
{
    // set up matrix mixer storage space
	int size, i;
	
	// allocate for the player list, vu meters lists and source locking lists at the end
	size = gLockedMem->inBus * (sizeof(ARPlayer *) + sizeof(sourceRec));
	size = size + gLockedMem->outBus * chanWidth * (2 * sizeof(float) + sizeof(int));
	gLockedMem->pList = (ARPlayer **)allocateLockedBlock(size);
	// set pointers
	gLockedMem->sourceList = (sourceRec *)(gLockedMem->pList + (gLockedMem->inBus * sizeof(ARPlayer *)));
	gLockedMem->avrOutputMeter = (float *)(gLockedMem->sourceList + (gLockedMem->inBus * sizeof(sourceRec)));
	gLockedMem->pkOutputMeter = (float *)(gLockedMem->avrOutputMeter + (gLockedMem->outBus * chanWidth * sizeof(float)));
	gLockedMem->mmMap = (int *)(gLockedMem->pkOutputMeter + (gLockedMem->outBus * chanWidth * sizeof(float)));
	
	// set up monitor mix minus channel mapping array to exclude all output busses except the first
    for(i=0;i<gLockedMem->outBus * chanWidth;i++){
		if(i < chanWidth)
			gLockedMem->mmMap[i] = i;  
		else
			gLockedMem->mmMap[i] = -1;  
    }

	// clear player and source list
    for(i=0;i<gLockedMem->inBus;i++){
        gLockedMem->pList[i] = NULL;  
        gLockedMem->sourceList[i].connectedPtr = NULL;
        gLockedMem->sourceList[i].requestPtr = NULL;
    }
			    
	// allocate source buffer for storing sample data from the various sources prior to mixing
	gLockedMem->sourceBuffers = allocateAudioBufferList(coreBufferSize, chanWidth, sizeof(float), &gLockedMem->sourceBufSize);  
    
	// set mixer input format
    mixerInputFormat.mSampleRate = coreRate;
	mixerInputFormat.mFormatID = kAudioFormatLinearPCM;
	mixerInputFormat.mFormatFlags =kAudioFormatFlagsNativeFloatPacked | kAudioFormatFlagIsNonInterleaved;
	mixerInputFormat.mBitsPerChannel = sizeof(float) * 8;
	mixerInputFormat.mChannelsPerFrame = chanWidth;
	mixerInputFormat.mBytesPerFrame = sizeof(float);
	mixerInputFormat.mFramesPerPacket = 1;
	mixerInputFormat.mBytesPerPacket = mixerInputFormat.mBytesPerFrame * mixerInputFormat.mFramesPerPacket;
	
	// set mixer output format
    mixerOutputFormat.mSampleRate = coreRate;
	mixerOutputFormat.mFormatID = kAudioFormatLinearPCM;
	mixerOutputFormat.mFormatFlags = kAudioFormatFlagsNativeFloatPacked | kAudioFormatFlagIsNonInterleaved;
	mixerOutputFormat.mBitsPerChannel = sizeof(float) * 8;
	mixerOutputFormat.mChannelsPerFrame = gLockedMem->outBus * chanWidth;
	mixerOutputFormat.mBytesPerFrame = sizeof(float);
	mixerOutputFormat.mFramesPerPacket = 1;
	mixerOutputFormat.mBytesPerPacket = mixerOutputFormat.mBytesPerFrame * mixerOutputFormat.mFramesPerPacket;

    // Alloc Master Output Bus ring buffer that will hold data between the mixer and all output audio devices
    // 16 second (bufDuration) buffer length
    gLockedMem->BusBuffer = new AudioRingBuffer();	
    gLockedMem->BusBuffer->Allocate(mixerOutputFormat.mChannelsPerFrame, mixerOutputFormat.mBytesPerFrame, (uint32_t)(coreRate * bufDuration));

    // Alloc Master Output Bus ring buffer that will hold data between the mixer and all output audio devices
    // 16 second (bufDuration) buffer length
    gLockedMem->cueInsertBuffer = new AudioRingBuffer();	
    gLockedMem->cueInsertBuffer->Allocate(mixerInputFormat.mChannelsPerFrame, mixerInputFormat.mBytesPerFrame, (uint32_t)(coreRate * bufDuration));
    
	// register vu meters
	vuObject->lock();
	vuObject->registerEntry(gLockedMem->pkOutputMeter, gLockedMem->avrOutputMeter, 0, gLockedMem->outBus * chanWidth);
	vuObject->unlock();

    return;
}

void CloseAudioSystem(void)
{
	int size;

    // delete all output devices
    pthread_mutex_lock(&oMutex);

	while(!outputMap.empty()){
		delete outputMap.begin()->second;
		outputMap.erase(outputMap.begin());
	}	
    outputMap.clear();
    pthread_mutex_unlock(&oMutex);
        
    // free the mixer buffers
	if(gLockedMem->BusBuffer){
		delete gLockedMem->BusBuffer;
		gLockedMem->BusBuffer = NULL;
	}
	if(gLockedMem->cueInsertBuffer){
		delete gLockedMem->cueInsertBuffer;
		gLockedMem->cueInsertBuffer = NULL;
	}
	if(gLockedMem->sourceBuffers){
		freeLockedBlock(gLockedMem->sourceBuffers, gLockedMem->sourceBufSize);
		gLockedMem->sourceBuffers = NULL;
	}
	
	// release block plus player list, vu meters lists and source locking lists
	size = gLockedMem->inBus * (sizeof(ARPlayer *) + sizeof(sourceRec));
	size = size + gLockedMem->outBus * chanWidth * (2 * sizeof(float) + sizeof(int));
	freeLockedBlock(gLockedMem->pList, size);
}

void ReturnDeviceList(int cs, char *buf, uint32_t size)
{
    CFStringRef	devUID;
    AudioBufferList *bufferlistPtr;
    AudioDeviceID* theDeviceList;
    uint32_t nChan, theSize, theNumberDevices, i, j;
    char str[1024], name[1024];
    int tx_length;
    OSStatus OSerr;
	CFStringRef escapedStr;
    
    OSerr = AudioHardwareGetPropertyInfo (
                    kAudioHardwarePropertyDevices,
                    &theSize, NULL );
    if (OSerr)
        return;
                            
    theNumberDevices = theSize / sizeof(AudioDeviceID);
    theDeviceList = (AudioDeviceID*) malloc(theNumberDevices * sizeof(AudioDeviceID));
    theSize = theNumberDevices * sizeof(AudioDeviceID);
    
    OSerr = AudioHardwareGetProperty (
                    kAudioHardwarePropertyDevices,
                    &theSize, theDeviceList );
    if (OSerr)
        return;
        
    for(i=0; i<theNumberDevices; i++){    // loop through the list           
        theSize = sizeof name;
        OSerr = AudioDeviceGetProperty(
                    theDeviceList[i], 0, false,
                    kAudioDevicePropertyDeviceName,
                    &theSize, name);
        if (OSerr)
            return;
        theSize = sizeof(CFStringRef);    
        OSerr = AudioDeviceGetProperty(
                    theDeviceList[i], 0, false,
                    kAudioDevicePropertyDeviceUID,
                    &theSize, &devUID);
 
        if(OSerr)
            return;

		// URL type escape (%nn) the string, except for " " chars.
		if(escapedStr = CFURLCreateStringByAddingPercentEscapes(NULL, devUID, CFSTR("><:=+-)(#!@"), NULL, kCFStringEncodingUTF8)){
			CFStringGetCString(escapedStr, str, sizeof str, kCFStringEncodingUTF8);
			tx_length = snprintf(buf, size, "%u\t%s\t%s\t", (unsigned int)theDeviceList[i], name, str);
			my_send( cs, buf, tx_length, false);
 			CFRelease(escapedStr);
		}
        CFRelease(devUID);
        
            
        // count outputs
        AudioDeviceGetPropertyInfo(theDeviceList[i], 0, false, 
                    kAudioDevicePropertyStreamConfiguration, 
                    &theSize, NULL);

        bufferlistPtr = (AudioBufferList*)malloc(theSize);

        nChan = 0;      
        OSerr = AudioDeviceGetProperty(theDeviceList[i], 0, false,
                    kAudioDevicePropertyStreamConfiguration,
                    &theSize, bufferlistPtr);
        if (!OSerr){
            for (j=0; j < bufferlistPtr->mNumberBuffers; j++)
                nChan = nChan + bufferlistPtr->mBuffers[j].mNumberChannels;
        }                
        free(bufferlistPtr);
        tx_length = snprintf(buf, size, "%u\t", (unsigned int)nChan);
        my_send(cs, buf, tx_length, false);

        // count inputs     
        AudioDeviceGetPropertyInfo(theDeviceList[i], 0, true, 
                    kAudioDevicePropertyStreamConfiguration, 
                    &theSize, NULL);

        bufferlistPtr = (AudioBufferList*)malloc(theSize);

        nChan = 0;
        OSerr = AudioDeviceGetProperty(theDeviceList[i], 0, true,
                    kAudioDevicePropertyStreamConfiguration,
                    &theSize, bufferlistPtr);
        if (!OSerr){
            for (j=0; j < bufferlistPtr->mNumberBuffers; j++)
                nChan = nChan + bufferlistPtr->mBuffers[j].mNumberChannels;
        }
        free(bufferlistPtr);
        tx_length = snprintf(buf, size, "%u\n", (unsigned int)nChan);
        my_send( cs, buf, tx_length, false);
    }
    if (theDeviceList) free(theDeviceList);
}

uint32_t GetDeviceID(const char *UID)
{
    CFStringRef	devUID;
    OSStatus OSerr;
    AudioDeviceID devID;
    uint32_t theSize;
    AudioValueTranslation passData;
 
	if(UID == NULL)
		return 0;
		
    devUID = CFStringCreateWithCString(NULL, UID, kCFStringEncodingUTF8);

    passData.mInputData = &devUID;
    passData.mInputDataSize = sizeof(CFStringRef);
    passData.mOutputData = &devID;
    passData.mOutputDataSize = sizeof(AudioDeviceID);   
    
    theSize = sizeof(passData);    
    OSerr = AudioHardwareGetProperty(kAudioHardwarePropertyDeviceForUID, &theSize, &passData);

    //deallocate                                    
    CFRelease(devUID);
    if(OSerr)
        return 0;
    if(devID == kAudioDeviceUnknown)
        return 0;
    return (uint32_t)devID;
}

void ReturnDevChNames(int cs, char *buf, uint32_t size, const char *UID, unsigned char input)
{
	// channel names for given device input and output channels, if any
	
    AudioDeviceID theDevice;
	AudioBufferList *bufferlistPtr;
    uint32_t nChan, i;
    uint32_t theSize;
	char name[256];
    int tx_length;
    OSStatus OSerr;
    
    if(theDevice = GetDeviceID(UID)){
		// count channels     
        AudioDeviceGetPropertyInfo(theDevice, 0, input, 
                    kAudioDevicePropertyStreamConfiguration, 
                    &theSize, NULL);

        bufferlistPtr = (AudioBufferList*)malloc(theSize);

        nChan = 0;
        OSerr = AudioDeviceGetProperty(theDevice, 0, input,
                    kAudioDevicePropertyStreamConfiguration,
                    &theSize, bufferlistPtr);
        if(!OSerr){
            for (i=0; i < bufferlistPtr->mNumberBuffers; i++)
                nChan = nChan + bufferlistPtr->mBuffers[i].mNumberChannels;
        }
        free(bufferlistPtr);
		
        for(i=0; i < nChan; i++){
            theSize = sizeof name;
            OSerr = AudioDeviceGetProperty(theDevice, i+1, input, kAudioDevicePropertyChannelName, &theSize, name);
            if((OSerr == noErr) && (strlen(name) > 0)){
                tx_length = snprintf(buf, size, "%u\t%s\n", (unsigned int)i, name);
                my_send( cs, buf, tx_length, false);
            }else{
                tx_length = snprintf(buf, size, "%u\tChannel %u\n", (unsigned int)i, (unsigned int)(i+1));
                my_send( cs, buf, tx_length, false);
			}
        }
    }
}

unsigned char SetDMDest(const char *UID, int chan, uint32_t dest)
{
	// Set Direct Monitoring destination assignment for the given device and input channel
	
    AudioDeviceID theDevice;
	float vol;
	uint32_t value;
    OSStatus OSerr;
    
    if(theDevice = GetDeviceID(UID)){
		if(dest){
			value = true;
			OSerr = AudioDeviceSetProperty(theDevice, NULL, chan, true, kAudioDevicePropertyPlayThru, sizeof(value), &value);
			if(OSerr == noErr){
				OSerr = AudioDeviceSetProperty(theDevice, NULL, chan, true, kAudioDevicePropertyPlayThruDestination, sizeof(dest), &dest);
				if(OSerr == noErr){
					vol = 0.0; // mute initially when set
					AudioDeviceSetProperty(theDevice, NULL, chan, true, kAudioDevicePropertyPlayThruVolumeScalar, sizeof(vol), &vol);
					return true;
				}
			}
		}else{
			value = false;
			AudioDeviceSetProperty(theDevice, NULL, chan, true, kAudioDevicePropertyPlayThru, sizeof(value), &value);
		}
    }
	return false;
}

unsigned char ReturnDevDMDest(uint32_t *dest, string *name, const char *UID, int chan)
{
	// Get Direct Monitoring destination assignment for the given device and input channel
	
    AudioDeviceID theDevice;
    uint32_t theSize;
	AudioValueTranslation valStruct;
	char cName[256];
    OSStatus OSerr;
    
    if(theDevice = GetDeviceID(UID)){
		theSize = sizeof(*dest);
		OSerr = AudioDeviceGetProperty(theDevice, chan, true, kAudioDevicePropertyPlayThruDestination, &theSize, dest);
		if(OSerr == noErr){
			if(name){
				valStruct.mInputData = dest;
				valStruct.mInputDataSize = theSize;
				valStruct.mOutputData = cName;
				valStruct.mOutputDataSize = sizeof(cName);
				
				OSerr = AudioDeviceGetProperty(theDevice, chan, true, kAudioDevicePropertyPlayThruDestinationNameForID, &theSize, &valStruct);
				if(OSerr == noErr)
					*name = string(cName);
				else{
					*name = "";
				}
			}
			return true;
		}
    }
	return false;
}

void ReturnDevDMDestList(int cs, char *buf, uint32_t size, const char *UID, int chan)
{
	// direct monitoring destination list for the given devive and input channel
	
    AudioDeviceID theDevice;
    uint32_t i, count;
    uint32_t theSize;
	uint32_t *destList;
	AudioValueTranslation valStruct;
	char name[256];
    int tx_length;
    OSStatus OSerr;
    
	if(theDevice = GetDeviceID(UID)){
		OSerr = AudioDeviceGetPropertyInfo(theDevice, chan, true, kAudioDevicePropertyPlayThruDestinations, &theSize, NULL);
		if(OSerr)
			return;

        if(!(destList = (uint32_t*)malloc(theSize)))
			return;
			
		OSerr = AudioDeviceGetProperty(theDevice, chan, true, kAudioDevicePropertyPlayThruDestinations, &theSize, destList);
		if(OSerr){
			free(destList);
			return;
		}

		count = theSize / sizeof(uint32_t);
		theSize = sizeof(uint32_t);
		for(i = 0; i < count; i++){
			valStruct.mInputData = &destList[i];
			valStruct.mInputDataSize = theSize;
			valStruct.mOutputData = name;
			valStruct.mOutputDataSize = sizeof(name);
			
			OSerr = AudioDeviceGetProperty(theDevice, chan, true, kAudioDevicePropertyPlayThruDestinationNameForID, &theSize, &valStruct);
			if(OSerr == noErr)
				tx_length = snprintf(buf, size, "%u\t%s\n", (unsigned int)destList[i], name);
			else
				tx_length = snprintf(buf, size, "%u\t\n", (unsigned int)destList[i]);
			my_send( cs, buf, tx_length, false);
        }
		if(destList) 
			free(destList);
    }
}

uint32_t createMetaRecord(string url)
{
    uint32_t 	theID;
    unsigned char	unique;
	static uint32_t lastID;
    
    dMutex->writeLock(true, "createMetaRecord");
    do{
        unique = true;
		// 20 bits only
		lastID++;
		theID = (lastID & 0x000FFFFF);
        // search through the metaList to make sure the ID is really unique
        meta_list_ptr 	dp;
        dp = metaList.find(theID);
        if(dp != metaList.end()){
            unique = false;
        }
    }while((unique == false) && (theID != 0));
	lastID = theID;
    metaList[theID] = new metaDataRec;
    metaList[theID]->users = 0;
    metaList[theID]->rev = 0;	// new record, revision zero
    metaList[theID]->metaData["URL"] = url; // URL value is minimum required value to be set
    dMutex->writeUnlock();
    return theID;   
}

void registerMetaUser(uint32_t UID)
{
    metaDataPtr rec;
    
    if(UID == 0)
        return;
    dMutex->writeLock(true, "registerMetaUser");
	if(rec = metaList[UID])
		rec->users = rec->users + 1;
    dMutex->writeUnlock();  
}

void deleteMetaRecord(uint32_t UID)
{
    metaDataPtr rec;
    if(UID == 0)
        return;
    dMutex->writeLock(true, "deleteMetaRecord");
    rec = metaList[UID];
	if(rec){
		rec->users = rec->users - 1;
		if(rec->users <= 0){
			// delete the pair given the key... no one is using this any more
			metaList.erase(UID);
			delete rec;
		}
	}else{
		dMutex->writeUnlock();
		return;
	}
	dMutex->writeUnlock();
}

unsigned char LoadPlayer(int *pNum, const char *url_str, uint32_t UID)
{
	CFURLRef url;
	CFStringRef type_str;
	char ctype[9];
	int i, maxp, p;
	uint32_t idx;
    unsigned char result;
	string client_maxp;
    
	// assumes player lock is already write locked ONLY IF *pNum >= 0, otherwide, we will assign a value to *pNum and lock it's mutex
	// caller must writeUnlock the lock IF we retrurn with *pNum >= 0!
	
	result = false;
	p = -1;
	if(url_str == NULL){
		return false;
	}
	if(strlen(url_str) < 1){
		return false;
	}
	if(*pNum >= gLockedMem->inBus){	
        goto bail;
	}
	
	if(!URLfromString(&url, url_str)){
		goto bail;
	}	
	type_str = CFURLCopyScheme(url);
	if(type_str == NULL){
		CFRelease(url);	
		goto bail;
	}
	// make lower case and c-string
	CFStringGetCString(type_str, ctype, sizeof(ctype), kCFStringEncodingUTF8); 
	for(idx = 0; idx < strlen(ctype); idx = idx + 1)
		ctype[idx] = tolower(ctype[idx]);
	CFRelease(type_str);
	
	if(*pNum < 0){
		// load next available player		
		client_maxp = GetMetaData(0, "client_players_visible");
		maxp = atoi(client_maxp.c_str());
		if(maxp <= 0)
			maxp = 8;
		if(maxp > gLockedMem->inBus)
			maxp = gLockedMem->inBus;
		for(i = 0; i < maxp; i++){
			p = lastp + i;
			if(p >= maxp)
				p = p - maxp;
			
			if(pLocks[p]->readLock(false)){
				if(gLockedMem->pList[p] == NULL)
					break;
				pLocks[p]->readUnlock();
			}
		}
		if(i == maxp){
			//no available players
			*pNum = -1;
			p = -1;
			goto bail;
		}else{
			*pNum = p;
			pLocks[p]->writeWithRead(true, "LoadPlayer");
		}
	}
    if(!strcmp(ctype, pType_audio_file))
        result = LoadFilePlayer(*pNum, url_str, url, UID);
    if(!strcmp(ctype, pType_input_device))
        result = LoadInputPlayer(*pNum, url_str, url, UID);
	if(!strcmp(ctype, pType_iax_line))
        result = LoadIAXPlayer(*pNum, url_str, url, UID);
	if(!strcmp(ctype, pType_http))
        result = LoadHttpPlayer(*pNum, url_str, url, UID);
    if(!strcmp(ctype, pType_rsp))
        result = LoadRspPlayer(*pNum, url_str, url, UID);
	if(!strcmp(ctype, pType_db_item))
        result = LoadItemPlayer(pNum, url_str, UID);
	CFRelease(url);	
	if((result) && (UID != 0)){
		// send out notifications
		struct notifyData	data;
		data.senderID = getSenderID();
		data.reference = EndianS32_NtoB(UID);
		data.value.iVal = 0;
		Notifier->MakeEntry(nType_mstat, &data, sizeof(data), -1);
	}
bail:
	if(p > -1){
		if(*pNum != p){
			// we locked a player but loading has changed it... we need to unlock our lock
			pLocks[p]->writeUnlock();
		}else
			lastp = p;
	}
    return result;
}

unsigned char LoadFilePlayer(int pNum,  const char *url_str, CFURLRef url, uint32_t UID)
{
    FilePlayer *player;
	char path[4096];
	float vol;
	uint32_t locUID;
    		
	if(CFURLGetFileSystemRepresentation(url, true, (unsigned char*)path, sizeof(path)) == false)
		return false;

    if (gLockedMem->pList[pNum] == NULL)
        player = new FilePlayer(pNum);
    else 
        return false;
    
	if(UID == 0){
		locUID = createMetaRecord(url_str);
		GetURLMetaData(locUID, url_str);
	}else
		locUID = UID;
	registerMetaUser(locUID);
    if(player->load(path, locUID)){  
		gLockedMem->pList[pNum] = player;
        // set the balance and bus output settings
        player->balChange(0.0);
        if(player->bus_assignment == 0){
			player->bus_assignment = atoi(GetMetaData(player->UID, "def_bus").c_str());
			if(player->bus_assignment == 0){
				player->bus_assignment = atoi(GetMetaData(0, "def_bus").c_str());
				if(player->bus_assignment == 0)
					player->bus_assignment = 5;		//bus 0 (monitor) and 2 (Main) by default
			}
		}
		vol = atof(GetMetaData(player->UID, "Volume").c_str());
		if((vol == 0.0) || (vol > 10)) vol = 1.0;
        player->volChange(vol);	
		// set memory position, if any
		vol = atof(GetMetaData(player->UID, "Memory").c_str());
		if(vol > 0.0)
			player->setPosition(vol);
		// set fade, if any
		player->fade = atof(GetMetaData(player->UID, "FadeOut").c_str());
		SetMetaData(player->UID, "Controls", hstr(ctl_vol | ctl_pos | ctl_fade, 8));
        return true;
    }else{
        // failed to load... delete
		deleteMetaRecord(locUID);
        delete player;
        return false;
    }
}

unsigned char LoadInputPlayer(int pNum, const char *url_str, CFURLRef url, uint32_t UID)
{
    InputPlayer *player, *iplayer;
	ARPlayer *instance;
    input_map_ptr dp;
	unsigned char isAbsolutePath;
	uint32_t locUID;
	CFStringRef input_str;
	AudioDeviceID thisDevID;
	char buf[256];
	float vol;
	int i, j;

	input_str = CFURLCopyStrictPath(url, &isAbsolutePath);
	if(input_str == NULL)
		return false;
	CFStringGetCString(input_str, buf, sizeof(buf), kCFStringEncodingUTF8);
	CFRelease(input_str);

	if(UID == 0){
		locUID = createMetaRecord(url_str);
		GetURLMetaData(locUID, url_str);
	}else
		locUID = UID;
	registerMetaUser(locUID);

    // get input definition by name
    pthread_mutex_lock( &iMutex );
    string key(buf);
    // find the pair given the key
    dp = inputMap.find(key);
    if (dp == inputMap.end()){
        // not found... exit
        pthread_mutex_unlock( &iMutex );
		deleteMetaRecord(locUID);
        return false;
    }

    if (gLockedMem->pList[pNum] == NULL)
        player = new InputPlayer(pNum);
    else{
		pthread_mutex_unlock( &iMutex );
		deleteMetaRecord(locUID);
        return false;
	}
     
	thisDevID = GetDeviceID((*dp).second->deviceUID.c_str());
	// make sure this same input is not already loaded
	for(i = 0; i < gLockedMem->inBus; i++){
		pLocks[i]->readLock(true);
		instance = gLockedMem->pList[i];
		if(instance != NULL){
			if(strcmp(instance->type, pType_input_device) == 0){
				// it's an input
				iplayer = (InputPlayer*)instance;
				if(iplayer->devID == thisDevID){
					// audio device ID's match
					for(j=0; i<chanWidth; j++){
						if(iplayer->chanMap[j] != (*dp).second->channelMap[j]) 
							break;
					}
					if(j == chanWidth){
						pLocks[i]->readUnlock();
						pthread_mutex_unlock( &iMutex );
						deleteMetaRecord(locUID);
						return false; // exact match match on channel map and device... already loaded in another player
					}
				}
			}
		}
		pLocks[i]->readUnlock();
	}
    if(player->load((*dp).second, key, locUID)){  
		gLockedMem->pList[pNum] = player;
		player->bus_assignment = (*dp).second->bus;
		if(player->bus_assignment == 0){
			if(player->bus_assignment == 0){
				player->bus_assignment = atoi(GetMetaData(player->UID, "def_bus").c_str());
				if(player->bus_assignment == 0){
					player->bus_assignment = atoi(GetMetaData(0, "def_bus").c_str());
					if(player->bus_assignment == 0)
						player->bus_assignment = 5;		//bus 0 (monitor) and 2 (Main) by default
				}
			}
		}
		player->mmcID = (*dp).second->mmcID;

		pthread_mutex_unlock( &iMutex );
		SetMetaData(player->UID, "Controls", hstr((*dp).second->controls, 8));
        // set the balance and bus output settings
        player->balChange(0.0);
 		vol = atof(GetMetaData(player->UID, "Volume").c_str());
		if((vol == 0.0) || (vol > 10)) vol = 1.0;
        player->volChange(vol);		// set the channel input gain, , locks already set
		// set fade, if any
		player->fade = atof(GetMetaData(player->UID, "Fade").c_str());
		if(player->fade == 0)
			player->fade = atof(GetMetaData(player->UID, "FadeOut").c_str());
		if(GetMetaData(player->UID, "Name").length() == 0)
			SetMetaData(player->UID, "Name", key);
        return true;
    }else{
        // failed to load... delete
	    pthread_mutex_unlock( &iMutex );
		deleteMetaRecord(locUID);
        delete player;
        return false;
    }
}

unsigned char LoadIAXPlayer(int pNum, const char *url_str, CFURLRef url, uint32_t UID)
{
    IAXPlayer *player;
	unsigned char isAbsolutePath;
	CFStringRef input_str;
	int lineNum, bus;
	uint32_t locUID;
	char buf[256];
	float vol;

	input_str = CFURLCopyStrictPath(url, &isAbsolutePath);
	if(input_str == NULL)
		return false;
	CFStringGetCString(input_str, buf, sizeof(buf), kCFStringEncodingUTF8);
	CFRelease(input_str);

	lineNum = atoi(buf);
	// create player instance
    if (gLockedMem->pList[pNum] == NULL)
        player = new IAXPlayer(pNum);
    else
        return false;
	
	if(UID == 0){
		locUID = createMetaRecord(url_str);
		GetURLMetaData(locUID, url_str);
	}else
		locUID = UID;
	registerMetaUser(locUID);
    if(player->load(lineNum, locUID)){  
		gLockedMem->pList[pNum] = player;
        // set the balance and bus output settings
        player->balChange(0.0);
		bus = atoi(GetMetaData(0, "iax_def_feed").c_str());
		// zero hapens to also be the default monitor bus
		vol = atoi(GetMetaData(0, "iax_def_feed_vol").c_str());
		if(vol == 0.0)
			vol = 0.5;
		player->setFeed(bus, vol);	// set feed to monitor bus, -6 dB
        if(player->bus_assignment == 0){
			player->bus_assignment = atoi(GetMetaData(0, "iax_def_bus").c_str());
			if(player->bus_assignment == 0){
				player->bus_assignment = atoi(GetMetaData(0, "def_bus").c_str());
				if(player->bus_assignment == 0)
					player->bus_assignment = 5;		//bus 0 (monitor) and 2 (Main) by default
			}
		}
		vol = atof(GetMetaData(player->UID, "Volume").c_str());
		if((vol == 0.0) || (vol > 10)) vol = atof(GetMetaData(0, "iax_def_vol").c_str());
		if(vol == 0.0) vol = 4.0;  // + 12 dB gain by deafult
        player->volChange(vol);	
		// set fade, if any
		player->fade = atof(GetMetaData(player->UID, "FadeOut").c_str());
		SetMetaData(player->UID, "Controls", hstr(ctl_vol | ctl_fade | ctl_feed, 8));
        return true;
    }else{
        // failed to load... delete
		deleteMetaRecord(locUID);
        delete player;
        return false;
    }
}

unsigned char LoadHttpPlayer(int pNum, const char *url_str, CFURLRef url, uint32_t UID)
{
    httpPlayer *player;
	unsigned char isAbsolutePath;
	CFStringRef input_str;
	int lineNum, bus;
	uint32_t locUID;
	char buf[256];
	float vol;
	
 return false;
 
/*	input_str = CFURLCopyStrictPath(url, &isAbsolutePath);
	if(input_str == NULL)
		return false;
	CFStringGetCString(input_str, buf, sizeof(buf), kCFStringEncodingUTF8);
	CFRelease(input_str);
	
	lineNum = atoi(buf);
	// create player instance
    if (gLockedMem->pList[pNum] == NULL)
        player = new IAXPlayer(pNum);
    else
        return false;
	
	if(UID == 0){
		locUID = createMetaRecord(url_str);
		GetURLMetaData(locUID, url_str);
	}else
		locUID = UID;
	registerMetaUser(locUID);
    if(player->load(lineNum, locUID)){  
		gLockedMem->pList[pNum] = player;
        // set the balance and bus output settings
        player->balChange(0.0);
		bus = atoi(GetMetaData(0, "iax_def_feed").c_str());
		// zero hapens to also be the default monitor bus
		vol = atoi(GetMetaData(0, "iax_def_feed_vol").c_str());
		if(vol == 0.0)
			vol = 0.5;
		player->setFeed(bus, vol);	// set feed to monitor bus, -6 dB
        if(player->bus_assignment == 0){
			player->bus_assignment = atoi(GetMetaData(0, "iax_def_bus").c_str());
			if(player->bus_assignment == 0){
				player->bus_assignment = atoi(GetMetaData(0, "def_bus").c_str());
				if(player->bus_assignment == 0)
					player->bus_assignment = 5;		//bus 0 (monitor) and 2 (Main) by default
			}
		}
		vol = atof(GetMetaData(player->UID, "Volume").c_str());
		if((vol == 0.0) || (vol > 10)) vol = atof(GetMetaData(0, "iax_def_vol").c_str());
		if(vol == 0.0) vol = 4.0;  // + 12 dB gain by deafult
        player->volChange(vol);	
		// set fade, if any
		player->fade = atof(GetMetaData(player->UID, "FadeOut").c_str());
		SetMetaData(player->UID, "Controls", hstr(ctl_vol | ctl_fade | ctl_feed, 8));
        return true;
    }else{
        // failed to load... delete
		deleteMetaRecord(locUID);
        delete player;
        return false;
    }
*/
}

unsigned char LoadRspPlayer(int pNum, const char *url_str, CFURLRef url, uint32_t UID)
{
    rspPlayer *player;
	unsigned char isAbsolutePath;
	CFStringRef input_str;
	int lineNum, bus;
	uint32_t locUID;
	char buf[256];
	float vol;
	
return false;
	
/*	input_str = CFURLCopyStrictPath(url, &isAbsolutePath);
	if(input_str == NULL)
		return false;
	CFStringGetCString(input_str, buf, sizeof(buf), kCFStringEncodingUTF8);
	CFRelease(input_str);
	
	lineNum = atoi(buf);
	// create player instance
    if (gLockedMem->pList[pNum] == NULL)
        player = new IAXPlayer(pNum);
    else
        return false;
	
	if(UID == 0){
		locUID = createMetaRecord(url_str);
		GetURLMetaData(locUID, url_str);
	}else
		locUID = UID;
	registerMetaUser(locUID);
    if(player->load(lineNum, locUID)){  
		gLockedMem->pList[pNum] = player;
        // set the balance and bus output settings
        player->balChange(0.0);
		bus = atoi(GetMetaData(0, "iax_def_feed").c_str());
		// zero hapens to also be the default monitor bus
		vol = atoi(GetMetaData(0, "iax_def_feed_vol").c_str());
		if(vol == 0.0)
			vol = 0.5;
		player->setFeed(bus, vol);	// set feed to monitor bus, -6 dB
        if(player->bus_assignment == 0){
			player->bus_assignment = atoi(GetMetaData(0, "iax_def_bus").c_str());
			if(player->bus_assignment == 0){
				player->bus_assignment = atoi(GetMetaData(0, "def_bus").c_str());
				if(player->bus_assignment == 0)
					player->bus_assignment = 5;		//bus 0 (monitor) and 2 (Main) by default
			}
		}
		vol = atof(GetMetaData(player->UID, "Volume").c_str());
		if((vol == 0.0) || (vol > 10)) vol = atof(GetMetaData(0, "iax_def_vol").c_str());
		if(vol == 0.0) vol = 4.0;  // + 12 dB gain by deafult
        player->volChange(vol);	
		// set fade, if any
		player->fade = atof(GetMetaData(player->UID, "FadeOut").c_str());
		SetMetaData(player->UID, "Controls", hstr(ctl_vol | ctl_fade | ctl_feed, 8));
        return true;
    }else{
        // failed to load... delete
		deleteMetaRecord(locUID);
        delete player;
        return false;
    }
*/
}

unsigned char LoadItemPlayer(int *pNum, const char *url_str, uint32_t UID)
{
	uint32_t localUID;

	// get metadata for URL
	// create a meta data record to hold results
	if(UID == 0){
		localUID = createMetaRecord(url_str);
		// fill the metadata record
		GetURLMetaData(localUID, url_str);
	}else
		localUID = UID;
	registerMetaUser(localUID);

			
	// make sure we have resolved the URL into something other than a database item again.
	if(GetMetaData(localUID, "Type") == string("item")){
		// resolved back into a db item... done with the metadata record... delete
		deleteMetaRecord(localUID);
		return false;	
	}
	
	// handle according to new type
	if(GetMetaData(localUID, "Type") == string("task")){
		// try running the task
		dbTaskRunner(localUID, true);
		deleteMetaRecord(localUID);
		*pNum = -1; // not actually in a player
		return false;
	}

	if(GetMetaData(localUID, "Type") == string("playlist")){
		// ***** plistaylists can't be loaded into a player! do nothing
		deleteMetaRecord(localUID);
		*pNum = -1; // not actually in a player
		return false;
	}
	
	if(atoi(GetMetaData(localUID, "Missing").c_str()) == 0){
		// And make sure the URL has changed so we don't end up in a recursive loop!
		if(GetMetaData(localUID, "URL") == string(url_str)){
			// resolved back into the same URL... done with the metadata record... delete
			deleteMetaRecord(localUID);
			return false;	
		}
		// re-enter the load player cycle with the newly resoved URL
		if(LoadPlayer(pNum, GetMetaData(localUID, "URL").c_str(), localUID, 0)){
			// and we are done!
			deleteMetaRecord(localUID);
			return true;
		}
	}
	// failed... done with the metadata record... delete
	deleteMetaRecord(localUID);
	return false;
}

int GetNextSegListPos(int *thisP)
{
	int i, count, pos;
	ARPlayer *instance;
	
	// assumes the list mutex is already either read or write locked!
	pos = 0;
	if(thisP)
		*thisP = -1;
	count = PlayList.size();
	if(count > gLockedMem->inBus)
		count = gLockedMem->inBus;
	i = count-1;
	while(i >= 0){
		instance = PlayList.at(i);
		if(instance != NULL){
			if(instance->status & status_hasPlayed){
				pos = i + 1;
				if(thisP)
					*thisP = instance->pNum;
				break;
			}
		}
		i--;
	}
    return pos;
}

unsigned char getPlayerUID(uint32_t *ref)
{
	int i;
	// the the meta-UID from the specified player
    i = *ref;
	if(!checkPnumber(i))
        return false;
    ARPlayer *instance;
	pLocks[i]->readLock(true);
    instance = gLockedMem->pList[i];
    if(instance == NULL){
		pLocks[i]->readUnlock();
        return false;
	}
    *ref = instance->UID;
	pLocks[i]->readUnlock();
    return true;
}

unsigned char getListPos(uint32_t *ref)
{
    // the the meta-UID from the specified player
    // assumes lMuxex is already locked
    ARPlayer *instance;
	if(*ref){
		for(uint32_t idx=0; idx<PlayList.size(); idx++){
			instance = PlayList.at(idx);
			if(*ref == instance->UID){
				*ref = idx;
				return true;
			}
		}
	}
    return false;
}
			
ProgramLog::ProgramLog(void)
{
	readPos = 0;
	writePos = 0;
	cueSize = 32;
	logChangeTime = 0;
	logCUE = (ProgramLogStruct**)malloc(sizeof(ProgramLogStruct*) * cueSize);
	for(int i = 0; i < cueSize; i++)
		logCUE[i] = new ProgramLogStruct;
	pthread_mutex_init(&wlock, NULL);
	pthread_mutex_init(&semlock, NULL);
	pthread_cond_init(&cueSemaphore, NULL);
	run = true;
	pthread_create(&log_thread, NULL, &ProgramLog::cueMonitor, this);
}

ProgramLog::~ProgramLog(void)
{
	run = false;
	pthread_cond_signal(&cueSemaphore);
	pthread_join(log_thread, NULL);
	pthread_mutex_destroy(&wlock);
	pthread_mutex_destroy(&semlock);
	pthread_cond_destroy(&cueSemaphore);
	for(int i = 0; i < cueSize; i++)
		 delete logCUE[i];
	free(logCUE);
	logCUE = NULL;
	cueSize = 0;
}

void ProgramLog::MakeEntry(ProgramLogStruct entry)
{
	time_t now;
	short pos;

	now = time(NULL);
	if(pthread_mutex_lock(&wlock))
		return; // lock error... do not make entry
	pos = writePos + 1;
	if(pos >= cueSize)
		pos = 0;
	if(pos != readPos){
		*logCUE[writePos] = entry;
		logCUE[writePos]->when = now;
		writePos = pos;
		pthread_cond_signal(&cueSemaphore);
	}
	pthread_mutex_unlock(&wlock);
}

void ProgramLog::UIDEntry(uint32_t passUID, unsigned char Added, unsigned char Played)
{
	ProgramLogStruct entryRec;
	
	entryRec.added = Added;
	entryRec.played = Played;
	entryRec.UID = passUID;	
	entryRec.post = 1;
	MakeEntry(entryRec);
}

void *ProgramLog::cueMonitor(void* refCon)
{	
	short pos;
	ProgramLogStruct *rec;
	
	ProgramLog *parent = (ProgramLog *)(refCon);
    do{
		while(parent->readPos != parent->writePos){
			rec = parent->logCUE[parent->readPos];
			if(rec->UID){ // fill in data from UID, if available
				// make sure the UID record still exists
				dMutex->readLock(true);
				if(metaList.find(rec->UID) == metaList.end()){
					// record is missing
					pos = parent->readPos + 1;
					if(pos >= parent->cueSize)
						pos = 0;
					parent->readPos = pos;
					dMutex->readUnlock();				
					continue;
				}
				// record still exists - set up strings
				rec->name = GetMetaData(rec->UID, "Name");
				rec->artist = GetMetaData(rec->UID, "Artist");
				rec->album = GetMetaData(rec->UID, "Album");
				rec->source = GetMetaData(rec->UID, "URL");
				rec->comment = GetMetaData(rec->UID, "Comment");
				rec->owner = GetMetaData(rec->UID, "Owner");
				rec->webURL = GetMetaData(rec->UID, "WebURL");
				// set up Integers
				rec->artistID = atol(GetMetaData(rec->UID, "ArtistID").c_str());
				rec->albumID = atol(GetMetaData(rec->UID, "AlbumID").c_str());
				rec->ownerID = atol(GetMetaData(rec->UID, "OwnerID").c_str());
				rec->ID = atol(GetMetaData(rec->UID, "ID").c_str());
				rec->logID = atol(GetMetaData(rec->UID, "logID").c_str());
				rec->location = atol(GetMetaData(0, "db_loc").c_str());
				
				if(atoi(GetMetaData(rec->UID, "NoLog").c_str())){
					rec->post = 0;
					rec->added = rec->added | 2;
				}else{
					if(atoi(GetMetaData(rec->UID, "NoPost").c_str())){
						rec->added = rec->added | 4;
						rec->post = 0;
					}else
						rec->post = 1;
				}
				
				dMutex->readUnlock();
			}
			if((parent->logCUE[parent->readPos]->added & 0x01)|| (parent->logCUE[parent->readPos]->played & log_busses)){
				// update database program log
				if(MakeLogEntry((ProgramLogStruct*)(parent->logCUE[parent->readPos]))){
					if(parent->logCUE[parent->readPos]->played || !(parent->logCUE[parent->readPos]->played || parent->logCUE[parent->readPos]->added)){
						// change the log changed time if the item was played AND the db was updated
						parent->logChangeTime = parent->logCUE[parent->readPos]->when;
						// new item started playing - execute the log script, if specified
						executeLogScript(rec->logID);
						// send out notifications
						struct notifyData	data;
						data.senderID = getSenderID();
						data.reference = 0;
						data.value.iVal = 0;
						Notifier->MakeEntry(nType_status, &data, sizeof(data), -1);						
					}
				}
			}
			if(parent->logCUE[parent->readPos]->played){
				// update all the recorder/streaming server now-playing meta data
				Recorder *rec;
				rMutex->readLock(true);
				for(uint32_t idx=0; idx<RecList.size(); idx++){
					rec = RecList.at(idx);
					rec->post((ProgramLogStruct*)(parent->logCUE[parent->readPos]));
				}
				rMutex->readUnlock();				
			}
			pos = parent->readPos + 1;
			if(pos >= parent->cueSize)
				pos = 0;
			parent->readPos = pos;
		}
        // Wait for someone to add something new to the cue
		pthread_mutex_lock( &parent->semlock );
		if((parent->run) && (parent->readPos == parent->writePos))
			pthread_cond_wait( &parent->cueSemaphore, &parent->semlock );
        pthread_mutex_unlock(&parent->semlock);
	}while(parent->run);
    pthread_exit(0);
}

void executeLogScript(uint32_t logID)
{
	uint32_t UID;
	string script, logIDStr, settings;
	
	script = GetMetaData(0, "sys_logscript");
	if(script.length()){
		logIDStr = ustr(logID);
		// set up parameters to pass the script:
		// previous item played log ID;
		// path to arserver settings config file;
		script = script + " " + logIDStr + " " + startup_path;
		// run it as an arserver task
		UID = createMetaRecord("");
		registerMetaUser(UID);
		Execute(script.c_str(), UID, 60);
		deleteMetaRecord(UID);
	}
}

void* allocateLockedBlock(size_t bytes)
{
	void *block;
	size_t	size, page;
	
	// allocate page aligned, full page multiple block of memory
	page = getpagesize();
	size = page * ((bytes / page) + 1);
    if(block = valloc(size))
		// lock it into wired memory
		if(mlock(block, size))				
			ServerLoger->MakeEntry("allocateLockedBlock- [mlock]: system failed to lock memory block into RAM; insuficcent memory?");
	return block;
}

float processLoad(void)
{
	static UnsignedWide rTime;
	static unsigned long pTime;
	unsigned long proc;
	UnsignedWide real;
	struct rusage usage;
	float load;
	uint32_t rDiff, pDiff;

	load = 0.0;
	Microseconds(&real);
	// real time (in uS) since last time through
	rDiff = real.lo - rTime.lo;
	rTime = real;
	// get process usage
	if(!getrusage(RUSAGE_SELF, &usage)){
		// convert time value structure to UnsignedWide
		proc = (unsigned long)(usage.ru_utime.tv_sec + usage.ru_stime.tv_sec) * 1000000;
		proc = proc + (unsigned long)(usage.ru_utime.tv_usec + usage.ru_stime.tv_usec);
		pDiff = proc - pTime;
		pTime = proc;
		load = ((float)pDiff / (float)rDiff) * (float)MPProcessors();
	}
	return load;
}

float totalLoad(void)
{
  	natural_t cpuCount;
	processor_cpu_load_info_t cpuLoadInfo;
	mach_msg_type_number_t infoCount;
	uint32_t i, type;
	uint32_t ticks;
	uint32_t totalTicks;
	uint32_t idleTicks;
	static uint32_t lastTotal;
	static uint32_t lastIdle;
	float load;
 
	totalTicks = 0;
	idleTicks = 0;
	if(host_processor_info(mach_host_self(), PROCESSOR_CPU_LOAD_INFO, &cpuCount, (processor_info_array_t *)&cpuLoadInfo, &infoCount))
		// mach error
		return 0.;

	for (i = 0; i < cpuCount; i++){
		for(type = 0; type < CPU_STATE_MAX; type++){
			ticks = cpuLoadInfo[i].cpu_ticks[type];
			totalTicks = totalTicks + ticks;
			if(type == CPU_STATE_IDLE)
				idleTicks = idleTicks + ticks;
		}
	}
	vm_deallocate(mach_task_self(), (vm_address_t)cpuLoadInfo, infoCount);

	if(totalTicks)
		load = 1.0 - (float)(idleTicks - lastIdle) / (float)(totalTicks - lastTotal);
	else 
		load = 0.0;
	lastTotal = totalTicks;
	lastIdle = idleTicks;
	return load;
}

float EndianFloat_NtoB(float val)
{
	union fi {
		float	f;
		uint32_t	i;
	} store;
	
	store.f = val;
	store.i = EndianU32_NtoB(store.i);
	return store.f;
}

unsigned char handle_modbuspoll(ctl_session *session)
{
	
	// modbuspoll period IP-address UnitID InputAddress config_file
	
	struct modbusPollRec *rec;
	char *param, *addr, *conf;
	char *end;
	int period;
	unsigned char unitID;
	unsigned short inputID;
	unsigned long aInt;
	TaskItem *task;
	
	// first parameter, poll period
	param = strtok_r(NULL, " ", &session->save_pointer);
	if(param != NULL){
		period = atoi(param);
		if(period > 0){
			// second parameter, ip-address of unit
			addr = strtok_r(NULL, " ", &session->save_pointer);
			if(addr != NULL){
				// third parameter, unitID
				param = strtok_r(NULL, " ", &session->save_pointer);
				if(param != NULL){
					aInt = strtoul(param, &end, 16);
					if(aInt <= 0xFF){
						unitID = aInt;
						// fourth parameter, inputID
						param = strtok_r(NULL, " ", &session->save_pointer);
						if(param != NULL){
							aInt = strtoul(param, &end, 16);
							if(aInt <= 0xFFFF){
								inputID = aInt;
								conf = strtok_r(NULL, " ", &session->save_pointer);
								if(conf != NULL){
									rec = (struct modbusPollRec*)malloc(sizeof(struct modbusPollRec));
									rec->period = period;
									rec->unitID = unitID;
									rec->inputID = inputID;
									strncpy(rec->addr, addr, sizeof(rec->addr));
									strncpy(rec->conf, conf, sizeof(rec->conf));

									task = new TaskItem("modbus poll:"+string(conf), modbusPoll, rec, 0L, 0L, false); // no timeout
									return rOK;
								}
							}
						}
					}
				}
			}
		}
	}

	session->errMSG = "Missing or bad parameter\n";
	return rError;
}

void modbusPollCleanUp(void *pass)
{
	struct modbusPollRec *rec;
	
	rec = (struct modbusPollRec *)pass;	 
	if(rec->sock >=0)
		close(rec->sock);
	free(rec);
}
 
void modbusPoll(TaskItem *parent)
{
	struct modbusPollRec *rec;
	char state, result;
	struct timespec timeout;

	rec = (struct modbusPollRec *)parent->userData;
	
    pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);
    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
	pthread_cleanup_push((void (*)(void *))modbusPollCleanUp, (void *)rec);
	
	timeout.tv_nsec = 0;
	timeout.tv_sec = rec->period;
	
	state = -1;
	rec->sock = -1;
	
    while(1){
		result = modbusQuery(&rec->sock, rec->addr, rec->unitID, rec->inputID);
		switch(result){
			case -1:
				ServerLoger->MakeEntry("Modbus Query: connection failed to "+string(rec->addr));
				break;
			case -2:
				ServerLoger->MakeEntry("Modbus Query: losted connection from "+string(rec->addr));
				break;
			case -3:
				ServerLoger->MakeEntry("Modbus Query: Invalid reply from "+string(rec->addr));
				break;
			case -4:
			case -5:			
				ServerLoger->MakeEntry("Modbus Query: Wrong size reply from "+string(rec->addr));
				break;
			case -6:			
				ServerLoger->MakeEntry("Modbus Query: Socket error from "+string(rec->addr));
				break;
			
			default:
				if((state >= 0) && (result != state)){
					modbusTrigger(result, rec->conf);
				}
				state = result;
		}
		nanosleep(&timeout, NULL);
    }
	pthread_cleanup_pop(1);
}

void modbusTrigger(unsigned char state, char *conf)
{
	string trig_path;
	TaskItem *task;
				   
	trig_path = GetMetaData(0, "file_trigger_dir");
	if(trig_path.length() > 0){
		if(trig_path[trig_path.length()-1] != '/'){
			// add trailing slash
			trig_path = trig_path + "/";
		}	
	}
	if(state)
		task = new TaskItem(trig_path+string(conf)+".on", loadConfigFromTask, NULL, 0L, 0L, false); // no timeout
	else
		task = new TaskItem(trig_path+string(conf)+".off", loadConfigFromTask, NULL, 0L, 0L, false); // no timeout
}						   

char modbusQuery(int *sock, char *addr, unsigned char unitID, unsigned short inputID)
{
	unsigned short *sptr;
	struct modbusData packet, reply;
	char *dest;
	size_t size, limit;
	int rx_length;
	struct sockaddr_in  adrRec;
	struct timeval tv;
	
	// format request packet
	bzero(&packet, sizeof(packet));
	packet.unit = unitID;
	packet.function = 2;						// Read Discrete Input modbus function code
	sptr = (unsigned short *)&packet.data[0];
	*sptr = htons(inputID);						// input address
	sptr = (unsigned short *)&packet.data[2];
	*sptr = htons(1);							// one bit only requested
	packet.length = 6;
	
	if(*sock < 0){	
		// open new connection if one doesn't already exist
		if((*sock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP)) >= 0){
			tv.tv_sec = 5;  
			tv.tv_usec = 0;  
			setsockopt(*sock, SOL_SOCKET, SO_RCVTIMEO, (struct timeval *)&tv, sizeof(struct timeval));
			setsockopt(*sock, SOL_SOCKET, SO_SNDTIMEO, (struct timeval *)&tv, sizeof(struct timeval));
			setsockopt(*sock, SOL_SOCKET, SO_NOSIGPIPE, NULL, 0);	
			bzero(&adrRec, sizeof(adrRec));
			adrRec.sin_family = AF_INET;
			adrRec.sin_port = htons(502);
			if(inet_pton(AF_INET, addr, &adrRec.sin_addr.s_addr) <= 0){
				// bad address failure
				close(*sock);
				*sock = -1;
				return -1;
			}
			if(connect(*sock, (struct sockaddr *)&adrRec, sizeof(adrRec)) != 0){
				// connection failure
				close(*sock);
				*sock = -1;
				return -1;
			}
		}
	}
	
	// send request
	if((rx_length = write(*sock, &packet, packet.length + 6)) < (packet.length + 6)){
		// connection failure
		close(*sock);
		*sock = -1;
		return -1;
	}

	// get reply
	dest = (char *)(&reply);
	size = 0;
	bzero(&reply, sizeof(reply));
	limit = 6; // start by reading the header only
	while((rx_length = read(*sock, dest+size, limit-size)) > 0){
		size = size + rx_length;
		if(size == 6){
			if(reply.pading != 0){
				// reply is too big!
				close(*sock);
				*sock = -1;
				return -5;
			}
			limit = reply.length + 6; // now read to the end of the packet only
		}
		if(size == limit){
			// we have a whole packet
			if((reply.length == 4) && (reply.function == 2) && (reply.unit == unitID) && (reply.data[0] == 1)){
				// valid reply
				return (reply.data[1] & 0x01);
			}else{
				// invalid reply
				return -3;
			}
		}
	}
	
	// lost connection
	close(*sock);
	*sock = -1;
	if(rx_length)	// negative number indicates socket error
		return -6;
	return -2;	// zero indicated connection closed or RX timeout
}


unsigned char handle_coilset(ctl_session *session, unsigned char val)
{
	char *param, *addr;
	char *end;
	unsigned long aInt;
	unsigned short *sptr;
	struct modbusData packet, reply;
	int sock;
	char *dest;
	size_t size, limit;
	int rx_length;
	struct sockaddr_in  adrRec;
	struct timeval tv;
	
	// first parameter, ip-address of unit
	addr = strtok_r(NULL, " ", &session->save_pointer);
	if(addr != NULL){		
		if((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP)) >= 0){
			tv.tv_sec = 1;  
			tv.tv_usec = 0;  
			setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (struct timeval *)&tv, sizeof(struct timeval));
			setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (struct timeval *)&tv, sizeof(struct timeval));
			setsockopt(sock, SOL_SOCKET, SO_NOSIGPIPE, NULL, 0);	
			bzero(&adrRec, sizeof(adrRec));
			adrRec.sin_family = AF_INET;
			adrRec.sin_port = htons(502);
			
			if(inet_pton(AF_INET, addr, &adrRec.sin_addr.s_addr) > 0){
				// second parameter, UnitID
				param = strtok_r(NULL, " ", &session->save_pointer);
				if(param != NULL){
					bzero(&packet, sizeof(packet));
					aInt = strtoul(param, &end, 16);
					if(aInt < 256){
						packet.unit = aInt;
						// third parameter, AddressID
						param = strtok_r(NULL, " ", &session->save_pointer);
						if(param != NULL){
							aInt = strtoul(param, &end, 16);
							if(aInt <= 0xFFFF){
								sptr = (unsigned short *)&packet.data[0];
								*sptr = htons(aInt);
								
								// fill in other packet values
								packet.function = 5;
								if(val) 
									aInt = 0xff00;
								else
									aInt = 0x0000;
								sptr = (unsigned short *)&packet.data[2];
								*sptr = htons(aInt);
								packet.length = 6;

								if(connect(sock, (struct sockaddr *)&adrRec, sizeof(adrRec)) == 0){
									write(sock, &packet, packet.length + 6);
									// get reply
									dest = (char *)(&reply);
									size = 0;
									bzero(&reply, sizeof(reply));
									limit = 6; // start by reading the header only
									while((rx_length = read(sock, dest+size, limit-size)) > 0){
										size = size + rx_length;
										if(size == 6){
											if((reply.pading != 0) || (reply.length != packet.length)){
												ServerLoger->MakeEntry("Modbus Send: Bad reply length from "+string(addr));
												break;
											}
											limit = reply.length + 6; // now read to the end of the packet only
										}
										if(size == limit){
											// we have a whole packet
											if(memcmp(&packet, &reply, size))
												ServerLoger->MakeEntry("Modbus Send: Reply mismatch from "+string(addr));
											break;
										}
									}
										
									if(rx_length < 0)
										ServerLoger->MakeEntry("Modbus Send: No reply from "+string(addr));
									close(sock);
									return rOK;
								}else{
									ServerLoger->MakeEntry("Modbus Send: Connection failed to "+string(addr));
									close(sock);
									return rOK;
								}
							}
						}
					}
				}
			}
			close(sock);
		}
	}
	session->errMSG = "Missing or bad parameter\n";
	return rError;
}
